// Importación de la biblioteca GLAD para manejar funciones de OpenGL
#include <glad/glad.h>

// Importación de la biblioteca GLFW para la creación de ventanas y manejo de entradas
#include <GLFW/glfw3.h>

// Importación de las librerías de GLM para operaciones con matrices y vectores en 3D
#include <glm/glm.hpp> 
#include <glm/gtc/matrix_transform.hpp> // Para transformaciones como rotaciones, traslaciones, escalado
#include <glm/gtc/type_ptr.hpp>         // Para obtener punteros de matrices

// Importación de la biblioteca STB_image para cargar imágenes
#include <stb_image.h>

// Importación de la biblioteca FreeType para renderizar texto en pantalla
#include <ft2build.h>
#include FT_FREETYPE_H   

// Inclusión de archivos personalizados de la aplicación, como Shader, Sphere, Camera
#include "Shader.h"
#include "Sphere.h"
#include "Camera.h"

// Inclusión de bibliotecas estándar para tareas generales como manejo de memoria, entrada/salida, etc.
#include <cstdlib>
#include <iostream>
#include <vector>
#include <map>         // Para contenedores de mapas clave-valor
#include <wtypes.h>    // Tipo de datos de Windows (utilizado para funciones relacionadas con Windows)
#include <ctime>       // Para manejo de fechas y tiempos
#include <filesystem>  // Para operaciones con archivos y directorios
#include <string>      // Para manipulación de cadenas de texto

// Definir M_PI, que es la constante de Pi, y habilitar el uso de funciones matemáticas
#define _USE_MATH_DEFINES
#include <math.h>

// Definición de la constante TAU, que es el doble de Pi (usado para circunferencias y rotaciones completas)
#define TAU (M_PI * 2.0)


// Callback para ajustar el tamaño del framebuffer cuando se cambia el tamaño de la ventana
void framebuffer_size_callback(GLFWwindow* window, int width, int height);

// Función que procesa las entradas del teclado para controlar la cámara o la vista
void processInput(GLFWwindow* window);

// Función para renderizar texto en la pantalla
void RenderText(Shader& s, std::string text, GLfloat x, GLfloat y, GLfloat scale, glm::vec3 color);

// Función para cargar una textura desde un archivo especificado en la ruta
unsigned int loadTexture(char const* path);

// Función para cargar un cubemap utilizando una lista de rutas de imágenes
unsigned int loadCubemap(std::vector<std::string> faces);

// Función para mostrar la información del planeta
void ShowInfo(Shader& s);

// Función para obtener la resolución de la pantalla del escritorio
void GetDesktopResolution(float& horizontal, float& vertical)
{
	RECT desktop; // Estructura para almacenar las coordenadas del área de la pantalla
	// Obtener un handle para la ventana del escritorio
	const HWND hDesktop = GetDesktopWindow();
	// Obtener las dimensiones de la ventana del escritorio y almacenarlas en la estructura desktop
	GetWindowRect(hDesktop, &desktop);
	// El rincón superior izquierdo tendrá coordenadas (0,0)
	// y el rincón inferior derecho tendrá coordenadas (horizontal, vertical)
	horizontal = desktop.right; // Establece el valor de ancho de la pantalla
	vertical = desktop.bottom;  // Establece el valor de alto de la pantalla
}


// Tiempo delta para calcular el tiempo transcurrido entre los frames
GLfloat deltaTime = 0.0f;

// Tiempo del último frame para calcular el tiempo transcurrido entre los frames
GLfloat lastFrame = 0.0f;

// Creación de la cámara en la posición (0.0f, 0.0f, 3.0f)
Camera camera(glm::vec3(0.0f, 0.0f, 3.0f));

// Bandera para indicar si la cámara está rotando
bool onRotate = false;

// Bandera para indicar si la cámara está en modo "FreeCam" (cámara libre)
bool onFreeCam = true;

// Bandera para activar o desactivar un "SkyBoxExtra"
bool SkyBoxExtra = false;

// Dimensiones de la ventana de la pantalla (ancho y alto)
float SCREEN_WIDTH = 800, SCREEN_HEIGHT = 600;

// Posición de un punto en el espacio 3D (por defecto, en el origen)
glm::vec3 point = glm::vec3(0.0f, 0.0f, 0.0f);

// Posición de un planeta en el espacio 3D (por defecto, en el origen)
glm::vec3 PlanetPos = glm::vec3(0.0f, 0.0f, 0.0f);

// Últimas coordenadas del mouse, inicializadas al centro de la pantalla
GLfloat lastX = (GLfloat)(SCREEN_WIDTH / 2.0);
GLfloat lastY = (GLfloat)(SCREEN_HEIGHT / 2.0);

// Velocidad del planeta para su movimiento
float PlanetSpeed = .1f;

// Identificador del planeta que se está visualizando (inicializado a 0)
int PlanetView = 0;

// Arreglo para almacenar las teclas presionadas
bool keys[1024];

// Ángulos de rotación de la escena en los ejes Y y X
GLfloat SceneRotateY = 0.0f;
GLfloat SceneRotateX = 0.0f;

// Bandera para indicar si el usuario está en la vista de un planeta
bool onPlanet = false;


// Callback que se ejecuta cada vez que se presiona o suelta una tecla
void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)
{
	// Verifica si se presiona la tecla ESC
	if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
		glfwSetWindowShouldClose(window, GL_TRUE); // Cierra la ventana si se presiona ESC

	// Verifica si se presiona la tecla P
	if (glfwGetKey(window, GLFW_KEY_P) == GLFW_PRESS)
	{
		// Código comentado que parece posicionar la cámara en el planeta
		// camera.Position = PlanetPos;

		onPlanet = true; // Activa la bandera indicando que estamos en el planeta
	}

	// Asegura que la tecla presionada está dentro del rango de 0 a 1023 (válido para el arreglo keys)
	if (key >= 0 && key < 1024)
	{
		// Si la acción es presionar una tecla
		if (action == GLFW_PRESS)
			keys[key] = true; // Marca la tecla como presionada en el arreglo keys

		// Si la acción es soltar una tecla
		else if (action == GLFW_RELEASE)
			keys[key] = false; // Marca la tecla como no presionada en el arreglo keys
	}
}


bool firstMouse = true;
GLfloat xoff = 0.0f, yoff = 0.0f;

struct Character {
	GLuint TextureID;   // ID handle of the glyph texture
	glm::ivec2 Size;    // Size of glyph
	glm::ivec2 Bearing;  // Offset from baseline to left/top of glyph
	GLuint Advance;    // Horizontal offset to advance to next glyph
};
std::map<GLchar, Character> Characters;
GLuint textVAO, textVBO;

struct PlanetInfo {
	std::string Name;
	std::string OrbitSpeed;
	std::string Mass;
	std::string Gravity;
};
PlanetInfo Info;

// Callback que se ejecuta cuando el mouse se mueve
void mouse_callback(GLFWwindow* window, double xpos, double ypos)
{
	// Si es el primer movimiento del mouse, inicializa las variables de posición
	if (firstMouse)
	{
		lastX = (GLfloat)xpos; // Guarda la posición actual en X como la última posición
		lastY = (GLfloat)ypos; // Guarda la posición actual en Y como la última posición
		firstMouse = false;    // Indica que ya no es el primer movimiento
	}

	// Calcula el desplazamiento en X desde la última posición del mouse
	GLfloat xoffset = (GLfloat)(xpos - lastX);
	// Calcula el desplazamiento en Y desde la última posición del mouse (invertido para alinearse con la vista)
	GLfloat yoffset = (GLfloat)(lastY - ypos);

	// Actualiza las variables globales de desplazamiento
	xoff = xoffset; // Asigna el desplazamiento en X a una variable global
	yoff = yoffset; // Asigna el desplazamiento en Y a una variable global

	// Actualiza las posiciones "últimas" del mouse
	lastX = (GLfloat)xpos; // Actualiza la última posición en X con la actual
	lastY = (GLfloat)ypos; // Actualiza la última posición en Y con la actual

	// Si la rotación de la escena está activa
	if (onRotate)
	{
		// Ajusta la rotación en Y de la escena usando el desplazamiento en Y
		SceneRotateY += yoffset * 0.1f;
		// Ajusta la rotación en X de la escena usando el desplazamiento en X
		SceneRotateX += xoffset * 0.1f;
	}

	// Procesa el movimiento del mouse para actualizar la vista de la cámara
	camera.ProcessMouseMovement(xoffset, yoffset);
}

// Callback que se ejecuta cuando se detecta un desplazamiento de la rueda del mouse
void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
{
	// Si el desplazamiento en Y es positivo (rueda hacia adelante)
	if (yoffset == 1)
		camera.ProcessKeyboard(SCROLL_FORWARD, deltaTime); // Procesa el movimiento hacia adelante en la cámara
	else
	{
		// Si el desplazamiento en Y es negativo o no es 1 (rueda hacia atrás)
		camera.ProcessKeyboard(SCROLL_BACKWARD, deltaTime); // Procesa el movimiento hacia atrás en la cámara
	}
}
// Callback que se ejecuta cuando se presiona o suelta un botón del mouse
void mouse_button_callback(GLFWwindow* window, int button, int action, int mods)
{
	// Verifica si está activada la cámara libre y la cámara aún no está en modo libre
	if (onFreeCam && !camera.FreeCam)
	{
		// Si se presiona el botón derecho del mouse
		if (button == GLFW_MOUSE_BUTTON_RIGHT && action == GLFW_PRESS)
			onRotate = true; // Activa la rotación de la escena
		else
			onRotate = false; // Desactiva la rotación de la escena
	}
}


int main() {
	GetDesktopResolution(SCREEN_WIDTH, SCREEN_HEIGHT); // obtener resolución para crear ventana
	camera.LookAtPos = point;

	/* INICIO GLFW*/
	glfwInit();
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	glfwWindowHint(GLFW_SAMPLES, 4);
	/* INICIO GLFW */

	/* CREACION GLFW WINDOW */
	GLFWwindow* window = glfwCreateWindow(SCREEN_WIDTH, SCREEN_HEIGHT, "LearnOpenGL", glfwGetPrimaryMonitor(), NULL);
	if (window == NULL)
	{
		std::cout << "Failed to create GLFW window" << std::endl;
		glfwTerminate();
		return -1;
	}
	glfwMakeContextCurrent(window);
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
	glfwSetCursorPosCallback(window, mouse_callback);
	glfwSetKeyCallback(window, key_callback);
	glfwSetScrollCallback(window, scroll_callback);
	glfwSetMouseButtonCallback(window, mouse_button_callback);
	/* CREACION GLFW WINDOW */


	/* CARGAR GLAD */
	if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
	{
		std::cout << "Failed to initialize GLAD" << std::endl;
		return -1;
	}
	/* CARGAR GLAD */


	/* CONFIGURACIÓN PARA LA REPRESENTACIÓN DE TEXTO */
	FT_Library ft;
	if (FT_Init_FreeType(&ft))
		std::cout << "ERROR::FREETYPE: Could not init FreeType Library" << std::endl;

	FT_Face face;
	if (FT_New_Face(ft, "fonts/ff.otf", 0, &face))
		std::cout << "ERROR::FREETYPE: Failed to load font" << std::endl;

	// ESTABLECER EL TAMAÑO DE GLIFOS
	FT_Set_Pixel_Sizes(face, 0, 48);

	// DESACTIVAR LA REESTRICCION DE ALINEACION
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

	// CARGAR LOS 128 PRIMEROS CARACTERES DEL CONJUNTO ASCII
	for (GLubyte c = 0; c < 128; c++)
	{
		// CARGAR CARACTER DE GLIFO
		if (FT_Load_Char(face, c, FT_LOAD_RENDER))
		{
			std::cout << "ERROR::FREETYTPE: Failed to load Glyph" << std::endl;
			continue;
		}
		// GENERAR TEXTURA
		GLuint texture;
		glGenTextures(1, &texture);
		glBindTexture(GL_TEXTURE_2D, texture);
		glTexImage2D(
			GL_TEXTURE_2D,
			0,
			GL_RED,
			face->glyph->bitmap.width,
			face->glyph->bitmap.rows,
			0,
			GL_RED,
			GL_UNSIGNED_BYTE,
			face->glyph->bitmap.buffer
		);
		// OPCIONES DE TEXTURA
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		// ALMACENA CARACTER PARA SU USO POSTERIOR
		Character character = {
			texture,
			glm::ivec2(face->glyph->bitmap.width, face->glyph->bitmap.rows),
			glm::ivec2(face->glyph->bitmap_left, face->glyph->bitmap_top),
			face->glyph->advance.x
		};
		Characters.insert(std::pair<GLchar, Character>(c, character));
	}
	glBindTexture(GL_TEXTURE_2D, 0);
	// TERMINAR FREETYPE UNA VEZ TERMINADO
	FT_Done_Face(face);
	FT_Done_FreeType(ft);
	/* CONFIGURACION DE REPRESENTACION DEL TEXTO */


	glEnable(GL_DEPTH_TEST);
	glEnable(GL_MULTISAMPLE);
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	/* SOMBRAS */
	Shader SimpleShader("simpleVS.vs", "simpleFS.fs");
	Shader SkyboxShader("skybox.vs", "skybox.fs");
	Shader texShader("simpleVS.vs", "texFS.fs");
	Shader TextShader("TextShader.vs", "TextShader.fs");
	/* SOMBRAS */

	// PROYECCION DEL TEXTO
	glm::mat4 Text_projection = glm::ortho(0.0f, SCREEN_WIDTH, 0.0f, SCREEN_HEIGHT);
	TextShader.Use();
	glUniformMatrix4fv(glGetUniformLocation(TextShader.ID, "projection"), 1, GL_FALSE, glm::value_ptr(Text_projection));

	float cube[] = {
		-0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
		 0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
		 0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
		 0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
		-0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
		-0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

		-0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
		 0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
		 0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
		 0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
		-0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
		-0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

		-0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
		-0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
		-0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
		-0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
		-0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
		-0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

		 0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
		 0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
		 0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
		 0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
		 0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
		 0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

		-0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
		 0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
		 0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
		 0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
		-0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
		-0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

		-0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
		 0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
		 0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
		 0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
		-0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
		-0.5f,  0.5f, -0.5f,  0.0f, 1.0f
	};
	float skyboxVertices[] = {
		// POSICIONES          
		-1.0f,  1.0f, -1.0f,
		-1.0f, -1.0f, -1.0f,
		 1.0f, -1.0f, -1.0f,
		 1.0f, -1.0f, -1.0f,
		 1.0f,  1.0f, -1.0f,
		-1.0f,  1.0f, -1.0f,

		-1.0f, -1.0f,  1.0f,
		-1.0f, -1.0f, -1.0f,
		-1.0f,  1.0f, -1.0f,
		-1.0f,  1.0f, -1.0f,
		-1.0f,  1.0f,  1.0f,
		-1.0f, -1.0f,  1.0f,

		 1.0f, -1.0f, -1.0f,
		 1.0f, -1.0f,  1.0f,
		 1.0f,  1.0f,  1.0f,
		 1.0f,  1.0f,  1.0f,
		 1.0f,  1.0f, -1.0f,
		 1.0f, -1.0f, -1.0f,

		-1.0f, -1.0f,  1.0f,
		-1.0f,  1.0f,  1.0f,
		 1.0f,  1.0f,  1.0f,
		 1.0f,  1.0f,  1.0f,
		 1.0f, -1.0f,  1.0f,
		-1.0f, -1.0f,  1.0f,

		-1.0f,  1.0f, -1.0f,
		 1.0f,  1.0f, -1.0f,
		 1.0f,  1.0f,  1.0f,
		 1.0f,  1.0f,  1.0f,
		-1.0f,  1.0f,  1.0f,
		-1.0f,  1.0f, -1.0f,

		-1.0f, -1.0f, -1.0f,
		-1.0f, -1.0f,  1.0f,
		 1.0f, -1.0f, -1.0f,
		 1.0f, -1.0f, -1.0f,
		-1.0f, -1.0f,  1.0f,
		 1.0f, -1.0f,  1.0f
	};

	/* GENERACION DE SKYBOX */
	unsigned int skyboxVAO, skyboxVBO;
	glGenVertexArrays(1, &skyboxVAO);
	glGenBuffers(1, &skyboxVBO);
	glBindVertexArray(skyboxVAO);
	glBindBuffer(GL_ARRAY_BUFFER, skyboxVBO);
	glBufferData(GL_ARRAY_BUFFER, sizeof(skyboxVertices), &skyboxVertices, GL_STATIC_DRAW);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
	

	/* GENERACION DE VERTICES PARA LAS ORBITAS */
	std::vector<float> orbVert;
	GLfloat xx;
	GLfloat zz;
	float angl;
	for (int i = 0; i < 2000; i++)
	{
		angl = (float)(M_PI / 2 - i * (M_PI / 1000));
		xx = sin(angl) * 100.0f;
		zz = cos(angl) * 100.0f;
		orbVert.push_back(xx);
		orbVert.push_back(0.0f);
		orbVert.push_back(zz);

	}
	

	/* VAO-VBO POR ORBITA*/
	GLuint VBO_t, VAO_t;
	glGenVertexArrays(1, &VAO_t);
	glGenBuffers(1, &VBO_t);
	glBindVertexArray(VAO_t);
	glBindBuffer(GL_ARRAY_BUFFER, VBO_t);
	glBufferData(GL_ARRAY_BUFFER, sizeof(float) * orbVert.size(), orbVert.data(), GL_STATIC_DRAW);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);
	glEnableVertexAttribArray(0);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindVertexArray(0);
	

	/* TEXTO RENDERIZADO VAO-VBO*/
	glGenVertexArrays(1, &textVAO);
	glGenBuffers(1, &textVBO);
	glBindVertexArray(textVAO);
	glBindBuffer(GL_ARRAY_BUFFER, textVBO);
	glBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * 6 * 4, NULL, GL_DYNAMIC_DRAW);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(GLfloat), 0);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindVertexArray(0);
	

	/* CARGAR TEXTURAS */
	unsigned int texture_earth = loadTexture("resources/planets/earth2k.jpg");
	unsigned int t_sun = loadTexture("resources/planets/2k_sun.jpg");
	unsigned int texture_moon = loadTexture("resources/planets/2k_moon.jpg");
	unsigned int texture_mercury = loadTexture("resources/planets/2k_mercury.jpg");
	unsigned int texture_venus = loadTexture("resources/planets/2k_mercury.jpg");
	unsigned int texture_mars = loadTexture("resources/planets/2k_mars.jpg");
	unsigned int texture_jupiter = loadTexture("resources/planets/2k_jupiter.jpg");
	unsigned int texture_saturn = loadTexture("resources/planets/2k_saturn.jpg");
	unsigned int texture_uranus = loadTexture("resources/planets/2k_uranus.jpg");
	unsigned int texture_neptune = loadTexture("resources/planets/2k_neptune.jpg");
	unsigned int texture_saturn_ring = loadTexture("resources/planets/r.jpg");
	unsigned int texture_earth_clouds = loadTexture("resources/planets/2k_earth_clouds.jpg");
	

	/* GENERACION ESFERA */
	Sphere Sun(100.0f, 36 * 5, 18 * 5);
	Sphere Mercury(10.0f, 36, 18);
	Sphere Venus(12.0f, 36, 18);
	Sphere Earth(11.8f, 36, 18);
	Sphere Mars(8.0f, 36, 18);
	Sphere Jupiter(40.0f, 36, 18);
	Sphere Saturn(37.0f, 36, 18);
	Sphere Uranus(30.0f, 36, 18);
	Sphere Neptune(30.0f, 36, 19);
	Sphere Moon(5.5f, 36, 18);
	

	std::vector<std::string> faces
	{
		"resources/skybox/starfield/starfield_rt.tga",
		"resources/skybox/starfield/starfield_lf.tga",
		"resources/skybox/starfield/starfield_up.tga",
		"resources/skybox/starfield/starfield_dn.tga",
		"resources/skybox/starfield/starfield_ft.tga",
		"resources/skybox/starfield/starfield_bk.tga",
	};
	std::vector<std::string> faces_extra
	{
		"resources/skybox/blue/bkg1_right.png",
		"resources/skybox/blue/bkg1_left.png",
		"resources/skybox/blue/bkg1_top.png",
		"resources/skybox/blue/bkg1_bot.png",
		"resources/skybox/blue/bkg1_front.png",
		"resources/skybox/blue/bkg1_back.png",
	};

	unsigned int cubemapTexture = loadCubemap(faces);
	unsigned int cubemapTextureExtra = loadCubemap(faces_extra);
	GLfloat camX = 10.0f;
	GLfloat camZ = 10.0f;

	camera.Position = glm::vec3(0.0f, 250.0f, -450.0f);
	camera.Yaw = 90.0f;
	camera.Pitch = -40.0f;
	camera.ProcessMouseMovement(xoff, yoff);
	camera.FreeCam = false;
	onFreeCam = true;
	glm::mat4 view;
	glm::vec3 PlanetsPositions[9];
	while (!glfwWindowShouldClose(window))
	{

		GLfloat currentFrame = (GLfloat)glfwGetTime();
		deltaTime = currentFrame - lastFrame;
		lastFrame = currentFrame;

		/* ZOOM CONTROL */
		if (!camera.FreeCam)
		{
			if (camera.Position.y < 200 && camera.Position.y > 200.0f)
				camera.MovementSpeed = 300.0f;
			if (camera.Position.y < 125.f && camera.Position.y > 70.0f)
				camera.MovementSpeed = 200.0f;
			if (camera.Position.y < 70.f && camera.Position.y > 50.0f)
				camera.MovementSpeed = 100.0f;

			if (camera.Position.y > 200 && camera.Position.y < 400.0f)
				camera.MovementSpeed = 400.0f;
			if (camera.Position.y > 125.f && camera.Position.y < 200.0f)
				camera.MovementSpeed = 300.0f;
			if (camera.Position.y > 70.f && camera.Position.y < 125.0f)
				camera.MovementSpeed = 200.0f;
		}
		/* ZOOM CONTROL */

		processInput(window); // input

		if (!onFreeCam)
		{
			SceneRotateY = 0.0f;
			SceneRotateX = 0.0f;
		}
		if (camera.FreeCam || PlanetView > 0)
			glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
		else glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);

		// render
		glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		SimpleShader.Use();

		glm::mat4 model = glm::mat4(1.0f);

		double viewX;
		double viewZ;
		glm::vec3 viewPos;

		SimpleShader.Use();
		glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCREEN_WIDTH / (float)SCREEN_HEIGHT, 0.1f, 10000.0f);
		SimpleShader.setMat4("model", model);
		SimpleShader.setMat4("view", view);
		SimpleShader.setMat4("projection", projection);

		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, t_sun);


		/* SOL */
		glm::mat4 model_sun;
		model_sun = glm::rotate(model_sun, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_sun = glm::rotate(model_sun, (GLfloat)glfwGetTime() * glm::radians(23.5f) * 0.25f, glm::vec3(0.0f, 0.0f, 1.f));
		model_sun = glm::translate(model_sun, point);
		SimpleShader.setMat4("model", model_sun);
		Sun.Draw();
		

		/* MERCURIO */
		glm::mat4 model_mercury;
		double xx = sin(glfwGetTime() * PlanetSpeed) * 100.0f * 2.0f * 1.3f;
		double zz = cos(glfwGetTime() * PlanetSpeed) * 100.0f * 2.0f * 1.3f;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_mercury);
		model_mercury = glm::translate(model_mercury, point);
		model_mercury = glm::rotate(model_mercury, glm::radians(SceneRotateY), glm::vec3(1.0f, 0.0f, 0.0f));
		model_mercury = glm::rotate(model_mercury, glm::radians(SceneRotateX), glm::vec3(0.0f, 0.0f, 1.0f));
		model_mercury = glm::translate(model_mercury, glm::vec3(xx, 0.0f, zz));
		PlanetsPositions[0] = glm::vec3(xx, 0.0f, zz);
		model_mercury = glm::rotate(model_mercury, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_mercury = glm::rotate(model_mercury, (GLfloat)glfwGetTime() * glm::radians(-90.0f) * 0.05f, glm::vec3(0.0f, 0.0f, 1.f));
		SimpleShader.setMat4("model", model_mercury);
		Mercury.Draw();
		

		/* VENUS */
		glm::mat4 model_venus;
		xx = sin(glfwGetTime() * PlanetSpeed * 0.75f) * 100.0f * 3.0f * 1.3f;
		zz = cos(glfwGetTime() * PlanetSpeed * 0.75f) * 100.0f * 3.0f * 1.3f;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_venus);
		model_venus = glm::translate(model_venus, point);
		model_venus = glm::rotate(model_venus, glm::radians(SceneRotateY), glm::vec3(1.0f, 0.0f, 0.0f));
		model_venus = glm::rotate(model_venus, glm::radians(SceneRotateX), glm::vec3(0.0f, 0.0f, 1.0f));
		model_venus = glm::translate(model_venus, glm::vec3(xx, 0.0f, zz));
		PlanetsPositions[1] = glm::vec3(xx, 0.0f, zz);
		model_venus = glm::rotate(model_venus, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_venus = glm::rotate(model_venus, glm::radians(-132.5f), glm::vec3(0.0f, 1.0f, 0.f));
		model_venus = glm::rotate(model_venus, (GLfloat)glfwGetTime() * glm::radians(-132.5f) * 0.012f, glm::vec3(0.0f, 0.0f, 1.f));
		SimpleShader.setMat4("model", model_venus);
		Venus.Draw();
		

		/* TIERRA */
		glm::mat4 model_earth;
		xx = sin(glfwGetTime() * PlanetSpeed * 0.55f) * 100.0f * 4.0f * 1.3f;
		zz = cos(glfwGetTime() * PlanetSpeed * 0.55f) * 100.0f * 4.0f * 1.3f;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_earth);
		model_earth = glm::translate(model_earth, point);
		model_earth = glm::rotate(model_earth, glm::radians(SceneRotateY), glm::vec3(1.0f, 0.0f, 0.0f));
		model_earth = glm::rotate(model_earth, glm::radians(SceneRotateX), glm::vec3(0.0f, 0.0f, 1.0f));
		model_earth = glm::translate(model_earth, glm::vec3(xx, 0.0f, zz));
		glm::vec3 EarthPoint = glm::vec3(xx, 0.0f, zz);
		PlanetsPositions[2] = glm::vec3(xx, 0.0f, zz);
		model_earth = glm::rotate(model_earth, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_earth = glm::rotate(model_earth, glm::radians(-33.25f), glm::vec3(0.0f, 1.0f, 0.f));
		model_earth = glm::rotate(model_earth, (GLfloat)glfwGetTime() * glm::radians(-33.25f) * 2.0f, glm::vec3(0.0f, 0.0f, 1.f));
		camera.LookAtPos = glm::vec3(model_earth[3][0], model_earth[3][1], model_earth[3][2]);
		SimpleShader.setMat4("model", model_earth);
		Earth.Draw();

		

		/* LUNA */
		glm::mat4 model_moon;
		xx = sin(glfwGetTime() * PlanetSpeed * 67.55f) * 100.0f * 0.5f * 1.3f;
		zz = cos(glfwGetTime() * PlanetSpeed * 67.55f) * 100.0f * 0.5f * 1.3f;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_moon);
		model_moon = glm::rotate(model_moon, glm::radians(SceneRotateY), glm::vec3(1.0f, 0.0f, 0.0f));
		model_moon = glm::rotate(model_moon, glm::radians(SceneRotateX), glm::vec3(0.0f, 0.0f, 1.0f));
		model_moon = glm::translate(model_moon, EarthPoint);
		model_moon = glm::translate(model_moon, glm::vec3(xx, 0.0f, zz));
		model_moon = glm::rotate(model_moon, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_moon = glm::rotate(model_moon, glm::radians(-32.4f), glm::vec3(0.0f, 1.0f, 0.f));
		model_moon = glm::rotate(model_moon, (GLfloat)glfwGetTime() * glm::radians(-32.4f) * 3.1f, glm::vec3(0.0f, 0.0f, 1.f));
		SimpleShader.setMat4("model", model_moon);
		Moon.Draw();
		


		/* MARTE */
		glm::mat4 model_mars;
		xx = sin(glfwGetTime() * PlanetSpeed * 0.35f) * 100.0f * 5.0f * 1.3f;
		zz = cos(glfwGetTime() * PlanetSpeed * 0.35f) * 100.0f * 5.0f * 1.3f;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_mars);
		model_mars = glm::translate(model_mars, point);
		model_mars = glm::rotate(model_mars, glm::radians(SceneRotateY), glm::vec3(1.0f, 0.0f, 0.0f));
		model_mars = glm::rotate(model_mars, glm::radians(SceneRotateX), glm::vec3(0.0f, 0.0f, 1.0f));
		model_mars = glm::translate(model_mars, glm::vec3(xx, 0.0f, zz));
		PlanetsPositions[3] = glm::vec3(xx, 0.0f, zz);
		model_mars = glm::rotate(model_mars, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_mars = glm::rotate(model_mars, glm::radians(-32.4f), glm::vec3(0.0f, 1.0f, 0.f));
		model_mars = glm::rotate(model_mars, (GLfloat)glfwGetTime() * glm::radians(-32.4f) * 2.1f, glm::vec3(0.0f, 0.0f, 1.f));
		SimpleShader.setMat4("model", model_mars);
		Mars.Draw();
		

		/* JUPITER */
		glm::mat4 model_jupiter;
		xx = sin(glfwGetTime() * PlanetSpeed * 0.2f) * 100.0f * 6.0f * 1.3f;
		zz = cos(glfwGetTime() * PlanetSpeed * 0.2f) * 100.0f * 6.0f * 1.3f;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_jupiter);
		model_jupiter = glm::translate(model_jupiter, point);
		model_jupiter = glm::rotate(model_jupiter, glm::radians(SceneRotateY), glm::vec3(1.0f, 0.0f, 0.0f));
		model_jupiter = glm::rotate(model_jupiter, glm::radians(SceneRotateX), glm::vec3(0.0f, 0.0f, 1.0f));
		model_jupiter = glm::translate(model_jupiter, glm::vec3(xx, 0.0f, zz));
		PlanetsPositions[4] = glm::vec3(xx, 0.0f, zz);
		model_jupiter = glm::rotate(model_jupiter, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_jupiter = glm::rotate(model_jupiter, glm::radians(-23.5f), glm::vec3(0.0f, 1.0f, 0.f));
		model_jupiter = glm::rotate(model_jupiter, (GLfloat)glfwGetTime() * glm::radians(-23.5f) * 4.5f, glm::vec3(0.0f, 0.0f, 1.f));
		SimpleShader.setMat4("model", model_jupiter);
		Jupiter.Draw();
		

		/* SATURNO */
		glm::mat4 model_saturn;
		xx = sin(glfwGetTime() * PlanetSpeed * 0.15f) * 100.0f * 7.0f * 1.3f;
		zz = cos(glfwGetTime() * PlanetSpeed * 0.15f) * 100.0f * 7.0f * 1.3f;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_saturn);
		model_saturn = glm::translate(model_saturn, point);
		model_saturn = glm::rotate(model_saturn, glm::radians(SceneRotateY), glm::vec3(1.0f, 0.0f, 0.0f));
		model_saturn = glm::rotate(model_saturn, glm::radians(SceneRotateX), glm::vec3(0.0f, 0.0f, 1.0f));
		model_saturn = glm::translate(model_saturn, glm::vec3(xx, 0.0f, zz));
		glm::vec3 SatrunPoint = glm::vec3(xx, 0.0f, zz);
		PlanetsPositions[5] = glm::vec3(xx, 0.0f, zz);
		model_saturn = glm::rotate(model_saturn, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_saturn = glm::rotate(model_saturn, glm::radians(-34.7f), glm::vec3(0.0f, 1.0f, 0.f));
		model_saturn = glm::rotate(model_saturn, (GLfloat)glfwGetTime() * glm::radians(-34.7f) * 4.48f, glm::vec3(0.0f, 0.0f, 1.f));
		SimpleShader.setMat4("model", model_saturn);
		Saturn.Draw();
		

		/* URANO */
		glm::mat4 model_uranus;
		xx = sin(glfwGetTime() * PlanetSpeed * 0.1f) * 100.0f * 8.0f * 1.3f;
		zz = cos(glfwGetTime() * PlanetSpeed * 0.1f) * 100.0f * 8.0f * 1.3f;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_uranus);
		model_uranus = glm::translate(model_uranus, point);
		model_uranus = glm::rotate(model_uranus, glm::radians(SceneRotateY), glm::vec3(1.0f, 0.0f, 0.0f));
		model_uranus = glm::rotate(model_uranus, glm::radians(SceneRotateX), glm::vec3(0.0f, 0.0f, 1.0f));
		model_uranus = glm::translate(model_uranus, glm::vec3(xx, 0.0f, zz));
		PlanetsPositions[6] = glm::vec3(xx, 0.0f, zz);
		model_uranus = glm::rotate(model_uranus, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_uranus = glm::rotate(model_uranus, glm::radians(-99.0f), glm::vec3(0.0f, 1.0f, 0.f));
		model_uranus = glm::rotate(model_uranus, (GLfloat)glfwGetTime() * glm::radians(-99.0f) * 4.5f, glm::vec3(0.0f, 0.0f, 1.f));
		SimpleShader.setMat4("model", model_uranus);
		Uranus.Draw();
		

		/* NEPTUNO */
		glm::mat4 model_neptune;
		xx = sin(glfwGetTime() * PlanetSpeed * 0.08f) * 100.0f * 9.0f * 1.3f;
		zz = cos(glfwGetTime() * PlanetSpeed * 0.08f) * 100.0f * 9.0f * 1.3f;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_neptune);

		model_neptune = glm::translate(model_neptune, point);
		model_neptune = glm::rotate(model_neptune, glm::radians(SceneRotateY), glm::vec3(1.0f, 0.0f, 0.0f));
		model_neptune = glm::rotate(model_neptune, glm::radians(SceneRotateX), glm::vec3(0.0f, 0.0f, 1.0f));
		model_neptune = glm::translate(model_neptune, glm::vec3(xx, 0.0f, zz));
		PlanetsPositions[7] = glm::vec3(xx, 0.0f, zz);
		model_neptune = glm::rotate(model_neptune, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_neptune = glm::rotate(model_neptune, glm::radians(-30.2f), glm::vec3(0.0f, 1.0f, 0.f));
		model_neptune = glm::rotate(model_neptune, (GLfloat)glfwGetTime() * glm::radians(-30.2f) * 4.0f, glm::vec3(0.0f, 0.0f, 1.f));

		SimpleShader.setMat4("model", model_neptune);
		Neptune.Draw();
		

		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_venus);

		/* ORBITAS */
		glBindVertexArray(VAO_t);
		glLineWidth(1.0f);
		glm::mat4 modelorb;
		for (float i = 2; i < 10; i++)
		{
			modelorb = glm::mat4(1);
			modelorb = glm::translate(modelorb, point);
			modelorb = glm::rotate(modelorb, glm::radians(SceneRotateY), glm::vec3(1.0f, 0.0f, 0.0f));
			modelorb = glm::rotate(modelorb, glm::radians(SceneRotateX), glm::vec3(0.0f, 0.0f, 1.0f));
			modelorb = glm::scale(modelorb, glm::vec3(i * 1.3f, i * 1.3f, i * 1.3f));
			SimpleShader.setMat4("model", modelorb);
			glDrawArrays(GL_LINE_LOOP, 0, (GLsizei)orbVert.size() / 3);

		}
		modelorb = glm::mat4(1);
		modelorb = glm::rotate(modelorb, glm::radians(SceneRotateY), glm::vec3(1.0f, 0.0f, 0.0f));
		modelorb = glm::rotate(modelorb, glm::radians(SceneRotateX), glm::vec3(0.0f, 0.0f, 1.0f));
		modelorb = glm::translate(modelorb, EarthPoint);
		modelorb = glm::scale(modelorb, glm::vec3(0.5f * 1.3f, 0.5f * 1.3f, 0.5f * 1.3f));
		SimpleShader.setMat4("model", modelorb);
		glDrawArrays(GL_LINE_LOOP, 0, (GLsizei)orbVert.size() / 3);
		

		/* ANILLOS DE SATURNO */
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_saturn_ring);
		glLineWidth(2.0f);
		GLfloat rr = 0.55f;
		for (int i = 0; i < 25; i++)
		{
			modelorb = glm::mat4(1);

			modelorb = glm::rotate(modelorb, glm::radians(SceneRotateY), glm::vec3(1.0f, 0.0f, 0.0f));
			modelorb = glm::rotate(modelorb, glm::radians(SceneRotateX), glm::vec3(0.0f, 0.0f, 1.0f));
			modelorb = glm::translate(modelorb, SatrunPoint);
			modelorb = glm::rotate(modelorb, glm::radians(30.0f), glm::vec3(0.0f, 0.0f, 1.0f));
			modelorb = glm::scale(modelorb, glm::vec3(rr, rr, rr));
			SimpleShader.setMat4("model", modelorb);
			glDrawArrays(GL_LINE_LOOP, 0, (GLsizei)orbVert.size() / 3);
			if (i == 15)
				rr += 0.030f;
			else
				rr += 0.01f;
		}
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_venus);
		glBindVertexArray(0);
		


		/* DIBUJAR SKYBOX */
		glDepthFunc(GL_LEQUAL);
		SkyboxShader.Use();
		view = glm::mat4(glm::mat3(camera.GetViewMatrix()));
		SkyboxShader.setMat4("view", view);
		SkyboxShader.setMat4("projection", projection);
		// skybox cubo
		glBindVertexArray(skyboxVAO);
		glActiveTexture(GL_TEXTURE0);
		if (SkyBoxExtra)
			glBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTextureExtra);
		else
			glBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTexture);
		glDrawArrays(GL_TRIANGLES, 0, 36);
		glBindVertexArray(0);
		glDepthFunc(GL_LESS);
		

		/* SEGUIMIENTO DEL PLANETA + MOSTRAR INFORMACION */
		switch (PlanetView)
		{
		case 1:
			viewX = sin(glfwGetTime() * PlanetSpeed) * 100.0f * 3.5f * 1.3f;
			viewZ = cos(glfwGetTime() * PlanetSpeed) * 100.0f * 3.5f * 1.3f;
			viewPos = glm::vec3(viewX, 50.0f, viewZ);
			view = glm::lookAt(viewPos, PlanetsPositions[0], glm::vec3(0.0f, 1.0f, 0.0f));
			ShowInfo(TextShader);
			break;

		case 2:
			viewX = sin(glfwGetTime() * PlanetSpeed * 0.75f) * 100.0f * 4.5f * 1.2f;
			viewZ = cos(glfwGetTime() * PlanetSpeed * 0.75f) * 100.0f * 4.5f * 1.2f;
			viewPos = glm::vec3(viewX, 50.0f, viewZ);
			view = glm::lookAt(viewPos, PlanetsPositions[1], glm::vec3(0.0f, 1.0f, 0.0f));
			ShowInfo(TextShader);
			break;

		case 3:
			viewX = sin(glfwGetTime() * PlanetSpeed * 0.55f) * 100.0f * 5.5f * 1.2f;
			viewZ = cos(glfwGetTime() * PlanetSpeed * 0.55f) * 100.0f * 5.5f * 1.2f;
			viewPos = glm::vec3(viewX, 50.0f, viewZ);
			view = glm::lookAt(viewPos, PlanetsPositions[2], glm::vec3(0.0f, 1.0f, 0.0f));
			ShowInfo(TextShader);
			break;

		case 4:
			viewX = sin(glfwGetTime() * PlanetSpeed * 0.35f) * 100.0f * 6.0f * 1.2f;
			viewZ = cos(glfwGetTime() * PlanetSpeed * 0.35f) * 100.0f * 6.0f * 1.2f;
			viewPos = glm::vec3(viewX, 20.0f, viewZ);
			view = glm::lookAt(viewPos, PlanetsPositions[3], glm::vec3(0.0f, 1.0f, 0.0f));
			ShowInfo(TextShader);
			break;

		case 5:
			viewX = sin(glfwGetTime() * PlanetSpeed * 0.2f) * 100.0f * 7.5f * 1.3f;
			viewZ = cos(glfwGetTime() * PlanetSpeed * 0.2f) * 100.0f * 7.5f * 1.3f;
			viewPos = glm::vec3(viewX, 50.0f, viewZ);
			view = glm::lookAt(viewPos, PlanetsPositions[4], glm::vec3(0.0f, 1.0f, 0.0f));
			ShowInfo(TextShader);
			break;

		case 6:
			viewX = sin(glfwGetTime() * PlanetSpeed * 0.15f) * 100.0f * 8.5f * 1.3f;
			viewZ = cos(glfwGetTime() * PlanetSpeed * 0.15f) * 100.0f * 8.5f * 1.3f;
			viewPos = glm::vec3(viewX, 50.0f, viewZ);
			view = glm::lookAt(viewPos, PlanetsPositions[5], glm::vec3(0.0f, 1.0f, 0.0f));
			ShowInfo(TextShader);
			break;

		case 7:
			viewX = sin(glfwGetTime() * PlanetSpeed * 0.1f) * 100.0f * 9.5f * 1.3f;
			viewZ = cos(glfwGetTime() * PlanetSpeed * 0.1f) * 100.0f * 9.5f * 1.3f;
			viewPos = glm::vec3(viewX, 50.0f, viewZ);
			view = glm::lookAt(viewPos, PlanetsPositions[6], glm::vec3(0.0f, 1.0f, 0.0f));
			ShowInfo(TextShader);
			break;

		case 8:
			viewX = sin(glfwGetTime() * PlanetSpeed * 0.08f) * 100.0f * 10.5f * 1.3f;
			viewZ = cos(glfwGetTime() * PlanetSpeed * 0.08f) * 100.0f * 10.5f * 1.3f;
			viewPos = glm::vec3(viewX, 50.0f, viewZ);
			view = glm::lookAt(viewPos, PlanetsPositions[7], glm::vec3(0.0f, 1.0f, 0.0f));
			ShowInfo(TextShader);
			break;

		case 0:
			view = camera.GetViewMatrix();
			// Renderiza el título principal del sistema solar en la esquina superior izquierda
			RenderText(TextShader, "EF_GRUPO11_SISTEMA_SOLAR (AVANCE) ",
				25.0f,                             // Coordenada X (margen izquierdo)
				SCREEN_HEIGHT - 30.0f,             // Coordenada Y (altura de la pantalla menos 30 píxeles)
				0.50f,                             // Escala del texto
				glm::vec3(0.7f, 0.7f, 0.11f));     // Color del texto (amarillo claro)

			// Renderiza el texto "DATOS:" debajo del título principal
			RenderText(TextShader, "DATOS: ",
				25.0f,                             // Coordenada X (margen izquierdo)
				SCREEN_HEIGHT - 55.0f,             // Coordenada Y (altura menos 55 píxeles)
				0.35f,                             // Escala del texto (un poco más pequeño)
				glm::vec3(0.7f, 0.7f, 0.11f));     // Color del texto (amarillo claro)

			// Renderiza información sobre el sol
			RenderText(TextShader, "1    :SOL ",
				25.0f,                             // Coordenada X (margen izquierdo)
				SCREEN_HEIGHT - 80.0f,             // Coordenada Y (altura menos 80 píxeles)
				0.35f,                             // Escala del texto
				glm::vec3(0.7f, 0.7f, 0.11f));     // Color del texto

			// Renderiza información sobre los planetas
			RenderText(TextShader, "8    : PLANETAS ",
				25.0f,                             // Coordenada X
				SCREEN_HEIGHT - 105.0f,            // Coordenada Y (altura menos 105 píxeles)
				0.35f,                             // Escala del texto
				glm::vec3(0.7f, 0.7f, 0.11f));     // Color del texto

			// Renderiza información sobre los satélites
			RenderText(TextShader, "415  : SATELLITES ",
				25.0f,                             // Coordenada X
				SCREEN_HEIGHT - 130.0f,            // Coordenada Y (altura menos 130 píxeles)
				0.35f,                             // Escala del texto
				glm::vec3(0.7f, 0.7f, 0.11f));     // Color del texto

			// Renderiza información sobre los cometas
			RenderText(TextShader, "3441 :COMETAS ",
				25.0f,                             // Coordenada X
				SCREEN_HEIGHT - 155.0f,            // Coordenada Y (altura menos 155 píxeles)
				0.35f,                             // Escala del texto
				glm::vec3(0.7f, 0.7f, 0.11f));     // Color del texto

			// Si la cámara está en modo libre, renderiza el texto "CAMARA LIBRE" en la esquina superior derecha
			if (camera.FreeCam) {
				RenderText(TextShader, "CAMARA LIBRE ",
					SCREEN_WIDTH - 200.0f,         // Coordenada X (ancho de la pantalla menos 200 píxeles)
					SCREEN_HEIGHT - 30.0f,         // Coordenada Y (altura menos 30 píxeles)
					0.35f,                         // Escala del texto
					glm::vec3(0.7f, 0.7f, 0.11f)); // Color del texto
			}

			// Si la cámara está en modo estático, renderiza el texto "CAMARA ESTATICA" en la esquina superior derecha
			if (onFreeCam) {
				RenderText(TextShader, "CAMARA ESTATICA ",
					SCREEN_WIDTH - 200.0f,         // Coordenada X
					SCREEN_HEIGHT - 60.0f,         // Coordenada Y (altura menos 60 píxeles para que no se superponga)
					0.35f,                         // Escala del texto
					glm::vec3(0.7f, 0.7f, 0.11f)); // Color del texto
			}
			// Fin del bloque de renderizado
			break;
		}
		if (PlanetView > 0)
			RenderText(TextShader, "CÁMARA PLANETARIA ", SCREEN_WIDTH - 200.0f, SCREEN_HEIGHT - 30.0f, 0.35f, glm::vec3(0.7f, 0.7f, 0.11f));
	


		// glfw: intercambia buffers y sondea eventos IO (teclas pulsadas, movimiento mouse)
		// -------------------------------------------------------------------------------
		glfwSwapBuffers(window);
		glfwPollEvents();
	}

	glDeleteVertexArrays(1, &VAO_t);
	glDeleteBuffers(1, &VBO_t);
	glfwTerminate();
	return 0;
}

// Función que procesa la entrada del teclado para controlar la cámara y el comportamiento del sistema
void processInput(GLFWwindow* window)
{
	// Si la tecla ESCAPE es presionada, cierra la ventana
	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
		glfwSetWindowShouldClose(window, true);

	// Si la tecla W es presionada, mueve la cámara hacia adelante
	if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
		camera.ProcessKeyboard(FORWARD, deltaTime);

	// Si la tecla S es presionada, mueve la cámara hacia atrás
	if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
		camera.ProcessKeyboard(BACKWARD, deltaTime);

	// Si la tecla A es presionada, mueve la cámara hacia la izquierda
	if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
		camera.ProcessKeyboard(LEFT, deltaTime);

	// Si la tecla D es presionada, mueve la cámara hacia la derecha
	if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
		camera.ProcessKeyboard(RIGHT, deltaTime);

	// Si la tecla E es presionada, activa una opción relacionada con el cielo (SkyboxExtra)
	if (glfwGetKey(window, GLFW_KEY_E) == GLFW_PRESS)
		SkyBoxExtra = true;

	// Si la tecla F1 es presionada, cambia la vista a la cámara libre
	if (glfwGetKey(window, GLFW_KEY_F1) == GLFW_PRESS)
	{
		PlanetView = 0; // Cambia la vista al planeta 0
		onFreeCam = false; // Desactiva la cámara libre
		camera.FreeCam = true; // Activa la cámara libre
	}

	// Si la tecla ESPACIO es presionada, cambia a una vista de cámara libre con configuraciones específicas
	if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS)
	{
		PlanetView = 0; // Cambia la vista al planeta 0
		onFreeCam = true; // Activa la cámara libre
		camera.FreeCam = false; // Desactiva la cámara libre
		camera.Position = glm::vec3(0.0f, 250.0f, -450.0f); // Configura la posición de la cámara
		camera.Yaw = 90.0f; // Configura el ángulo de giro de la cámara
		camera.Pitch = -40.0f; // Configura el ángulo de inclinación de la cámara
		camera.GetViewMatrix(); // Actualiza la matriz de vista
		camera.ProcessMouseMovement(xoff, yoff); // Procesa el movimiento del mouse
	}

	// Cambia la vista a cada planeta cuando se presionan las teclas 1 a 8, y asigna sus propiedades
	if (glfwGetKey(window, GLFW_KEY_1) == GLFW_PRESS)
	{
		PlanetView = 1; // Cambia la vista al planeta 1 (Mercurio)
		Info.Name = "MERCURIO"; // Establece el nombre del planeta
		Info.OrbitSpeed = "47,87"; // Establece la velocidad orbital del planeta
		Info.Mass = "0.32868"; // Establece la masa del planeta
		Info.Gravity = "0.38"; // Establece la gravedad del planeta
		onFreeCam = false; // Desactiva la cámara libre
		camera.FreeCam = false; // Desactiva la cámara libre
	}
	if (glfwGetKey(window, GLFW_KEY_2) == GLFW_PRESS)
	{
		PlanetView = 2; // Cambia la vista al planeta 2 (Venus)
		Info.Name = "VENUS"; // Establece el nombre del planeta
		Info.OrbitSpeed = "35,02"; // Establece la velocidad orbital del planeta
		Info.Mass = "0.32868"; // Establece la masa del planeta
		Info.Gravity = "0.90"; // Establece la gravedad del planeta
		onFreeCam = false; // Desactiva la cámara libre
		camera.FreeCam = false; // Desactiva la cámara libre
	}
	if (glfwGetKey(window, GLFW_KEY_3) == GLFW_PRESS)
	{
		PlanetView = 3; // Cambia la vista al planeta 3 (Tierra)
		Info.Name = "TIERRA"; // Establece el nombre del planeta
		Info.OrbitSpeed = "29,76"; // Establece la velocidad orbital del planeta
		Info.Mass = "5.97600"; // Establece la masa del planeta
		Info.Gravity = "1"; // Establece la gravedad del planeta
		onFreeCam = false; // Desactiva la cámara libre
		camera.FreeCam = false; // Desactiva la cámara libre
	}
	if (glfwGetKey(window, GLFW_KEY_4) == GLFW_PRESS)
	{
		PlanetView = 4; // Cambia la vista al planeta 4 (Marte)
		Info.Name = "MARTE"; // Establece el nombre del planeta
		Info.OrbitSpeed = "24,13"; // Establece la velocidad orbital del planeta
		Info.Mass = "0.63345"; // Establece la masa del planeta
		Info.Gravity = "0.38"; // Establece la gravedad del planeta
		onFreeCam = false; // Desactiva la cámara libre
		camera.FreeCam = false; // Desactiva la cámara libre
	}
	if (glfwGetKey(window, GLFW_KEY_5) == GLFW_PRESS)
	{
		PlanetView = 5; // Cambia la vista al planeta 5 (Jupiter)
		Info.Name = "JUPITER"; // Establece el nombre del planeta
		Info.OrbitSpeed = "13,07"; // Establece la velocidad orbital del planeta
		Info.Mass = "1876.64328"; // Establece la masa del planeta
		Info.Gravity = "2.55"; // Establece la gravedad del planeta
		onFreeCam = false; // Desactiva la cámara libre
	}
	if (glfwGetKey(window, GLFW_KEY_6) == GLFW_PRESS)
	{
		PlanetView = 6; // Cambia la vista al planeta 6 (Saturno)
		Info.Name = "SATURNO"; // Establece el nombre del planeta
		Info.OrbitSpeed = "9,67"; // Establece la velocidad orbital del planeta
		Info.Mass = "561.80376"; // Establece la masa del planeta
		Info.Gravity = "1.12"; // Establece la gravedad del planeta
		onFreeCam = false; // Desactiva la cámara libre
		camera.FreeCam = false; // Desactiva la cámara libre
	}
	if (glfwGetKey(window, GLFW_KEY_7) == GLFW_PRESS)
	{
		PlanetView = 7; // Cambia la vista al planeta 7 (Urano)
		Info.Name = "URANO"; // Establece el nombre del planeta
		Info.OrbitSpeed = "6,84"; // Establece la velocidad orbital del planeta
		Info.Mass = "86.05440"; // Establece la masa del planeta
		Info.Gravity = "0.97"; // Establece la gravedad del planeta
		onFreeCam = false; // Desactiva la cámara libre
		camera.FreeCam = false; // Desactiva la cámara libre
	}
	if (glfwGetKey(window, GLFW_KEY_8) == GLFW_PRESS)
	{
		PlanetView = 8; // Cambia la vista al planeta 8 (Neptuno)
		Info.Name = "NEPTUNO"; // Establece el nombre del planeta
		Info.OrbitSpeed = "5,48"; // Establece la velocidad orbital del planeta
		Info.Mass = "101.59200"; // Establece la masa del planeta
		Info.Gravity = "1.17"; // Establece la gravedad del planeta
		onFreeCam = false; // Desactiva la cámara libre
		camera.FreeCam = false; // Desactiva la cámara libre
	}
}

void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
	glViewport(0, 0, width, height);
}

// Función para cargar una textura cúbica (cubemap) a partir de una lista de rutas de imágenes
unsigned int loadCubemap(std::vector<std::string> faces)
{
	// Declara una variable para almacenar el ID de la textura
	unsigned int textureID;

	// Genera una nueva textura y asigna el ID generado a textureID
	glGenTextures(1, &textureID);

	// Asocia la textura actual al objetivo de textura cúbica
	glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);

	// Variables para almacenar las dimensiones y canales de las imágenes
	int width, height, nrChannels;

	// Recorre las caras del cubemap, que son las imágenes en las rutas proporcionadas
	for (unsigned int i = 0; i < faces.size(); i++)
	{
		// Carga la imagen de la ruta indicada por faces[i]
		unsigned char* data = stbi_load(faces[i].c_str(), &width, &height, &nrChannels, 0);

		// Si la imagen se cargó correctamente
		if (data)
		{
			// Carga la imagen como una cara del cubemap (una cara por cada valor de i)
			glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,
				0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);

			// Libera la memoria de la imagen después de cargarla
			stbi_image_free(data);
		}
		else
		{
			// Si la imagen no se pudo cargar, muestra un mensaje de error
			std::cout << "Cubemap texture failed to load at path: " << faces[i] << std::endl;
			// Asegúrate de liberar la memoria de los datos aunque la carga haya fallado
			stbi_image_free(data);
		}
	}

	// Configura los parámetros de filtrado y envolvimiento para la textura cúbica
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);  // Filtrado de minificación
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);  // Filtrado de magnificación
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);  // Envolvimiento en el eje S
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);  // Envolvimiento en el eje T
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);  // Envolvimiento en el eje R

	// Devuelve el ID de la textura cúbica cargada
	return textureID;
}

unsigned int loadTexture(char const* path)
{
	unsigned int textureID;
	glGenTextures(1, &textureID);

	int width, height, nrComponents;
	unsigned char* data = stbi_load(path, &width, &height, &nrComponents, 0);
	if (data)
	{
		GLenum format;
		if (nrComponents == 1)
			format = GL_RED;
		else if (nrComponents == 3)
			format = GL_RGB;
		else if (nrComponents == 4)
			format = GL_RGBA;

		glBindTexture(GL_TEXTURE_2D, textureID);
		glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);
		glGenerateMipmap(GL_TEXTURE_2D);

		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

		stbi_image_free(data);
	}
	else
	{
		std::cout << "La textura no se ha podido cargar en la ruta: " << path << std::endl;
		stbi_image_free(data);
	}

	return textureID;
}
void RenderText(Shader& s, std::string text, GLfloat x, GLfloat y, GLfloat scale, glm::vec3 color)
{
	// ACTIVAR EL ESTADO CORRESPONDIENTE	
	s.Use();
	glUniform3f(glGetUniformLocation(s.ID, "textColor"), color.x, color.y, color.z);
	glActiveTexture(GL_TEXTURE0);
	glBindVertexArray(textVAO);

	// RECORRER TODOS LOS CARACTERES
	std::string::const_iterator c;
	for (c = text.begin(); c != text.end(); c++)
	{
		Character ch = Characters[*c];

		GLfloat xpos = x + ch.Bearing.x * scale;
		GLfloat ypos = y - (ch.Size.y - ch.Bearing.y) * scale;

		GLfloat w = ch.Size.x * scale;
		GLfloat h = ch.Size.y * scale;
		// ACTUALIZAR VBO POR CADA CARACTER
		GLfloat vertices[6][4] = {
			{ xpos,     ypos + h,   0.0, 0.0 },
			{ xpos,     ypos,       0.0, 1.0 },
			{ xpos + w, ypos,       1.0, 1.0 },

			{ xpos,     ypos + h,   0.0, 0.0 },
			{ xpos + w, ypos,       1.0, 1.0 },
			{ xpos + w, ypos + h,   1.0, 0.0 }
		};
		// RENDERIZA LA TEXTURA DEL GLIFO 
		glBindTexture(GL_TEXTURE_2D, ch.TextureID);
		// ACTUALIZA EL CONTENIDO DE LA MEMORIA
		glBindBuffer(GL_ARRAY_BUFFER, textVBO);
		glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices);
		glBindBuffer(GL_ARRAY_BUFFER, 0);
		// Render quad
		glDrawArrays(GL_TRIANGLES, 0, 6);
		// AVANZAMOS LOS CURSORES AL SGTE GLIFO POR CAD 1/64 PIXELES
		x += (ch.Advance >> 6) * scale; 
	}
	glBindVertexArray(0);
	glBindTexture(GL_TEXTURE_2D, 0);
}

// Método para mostrar información del planeta en pantalla
void ShowInfo(Shader& s) // Recibe un shader como referencia para renderizar el texto
{
	// Renderiza el nombre del planeta en la parte superior izquierda
	RenderText(s,
		"Planeta: " + Info.Name,       // Texto que incluye "Planet: " concatenado con el nombre del planeta
		25.0f,                        // Posición X, 25 píxeles desde el borde izquierdo
		SCREEN_HEIGHT - 30.0f,        // Posición Y, altura total de la pantalla menos 30 píxeles
		0.35f,                        // Escala del texto, determina su tamaño
		glm::vec3(0.7f, 0.7f, 0.11f));// Color del texto en formato RGB (un amarillo claro)

	// Renderiza la velocidad orbital promedio del planeta
	RenderText(s,
		"Velocidad media orbital (km/s): " + Info.OrbitSpeed, // Texto con el valor de velocidad orbital
		25.0f,                        // Posición X, 25 píxeles desde el borde izquierdo
		SCREEN_HEIGHT - 50.0f,        // Posición Y, altura menos 50 píxeles para separarlo del texto anterior
		0.35f,                        // Escala del texto
		glm::vec3(0.7f, 0.7f, 0.11f));// Color del texto en formato RGB (amarillo claro)

	// Renderiza la masa del planeta
	RenderText(s,
		"Masa (kg * 10^24): " + Info.Mass, // Texto con el valor de la masa
		25.0f,                        // Posición X, 25 píxeles desde el borde izquierdo
		SCREEN_HEIGHT - 70.0f,        // Posición Y, altura menos 70 píxeles para separarlo del texto anterior
		0.35f,                        // Escala del texto
		glm::vec3(0.7f, 0.7f, 0.11f));// Color del texto en formato RGB (amarillo claro)

	// Renderiza la gravedad del planeta
	RenderText(s,
		"Gravedad (g): " + Info.Gravity, // Texto con el valor de la gravedad
		25.0f,                        // Posición X, 25 píxeles desde el borde izquierdo
		SCREEN_HEIGHT - 90.0f,        // Posición Y, altura menos 90 píxeles para separarlo del texto anterior
		0.35f,                        // Escala del texto
		glm::vec3(0.7f, 0.7f, 0.11f));// Color del texto en formato RGB (amarillo claro)
}
