// Importación de la biblioteca GLAD para manejar funciones de OpenGL
#include <glad/glad.h>

// Importación de la biblioteca GLFW para la creación de ventanas y manejo de entradas
#include <GLFW/glfw3.h>

// Importación de las librerías de GLM para operaciones con matrices y vectores en 3D
#include <glm/glm.hpp> 
#include <glm/gtc/matrix_transform.hpp> // Para transformaciones como rotaciones, traslaciones, escalado
#include <glm/gtc/type_ptr.hpp>         // Para obtener punteros de matrices

// Importación de la biblioteca STB_image para cargar imágenes
#include <stb_image.h>

// Importación de la biblioteca FreeType para renderizar texto en pantalla
#include <ft2build.h>
#include FT_FREETYPE_H   

// Inclusión de archivos personalizados de la aplicación, como Shader, Sphere, Camera
#include "Shader.h"
#include "Sphere.h"
#include "Camera.h"

// Inclusión de bibliotecas estándar para tareas generales como manejo de memoria, entrada/salida, etc.
#include <cstdlib>
#include <iostream>
#include <vector>
#include <map>         // Para contenedores de mapas clave-valor
#include <wtypes.h>    // Tipo de datos de Windows (utilizado para funciones relacionadas con Windows)
#include <ctime>       // Para manejo de fechas y tiempos
#include <filesystem>  // Para operaciones con archivos y directorios
#include <string>      // Para manipulación de cadenas de texto

// Definir M_PI, que es la constante de Pi, y habilitar el uso de funciones matemáticas
#define _USE_MATH_DEFINES
#include <math.h>

// Definición de la constante TAU, que es el doble de Pi (usado para circunferencias y rotaciones completas)
#define TAU (M_PI * 2.0)


// Callback para ajustar el tamaño del framebuffer cuando se cambia el tamaño de la ventana
void framebuffer_size_callback(GLFWwindow* window, int width, int height);

// Función que procesa las entradas del teclado para controlar la cámara o la vista
void processInput(GLFWwindow* window);

// Función para renderizar texto en la pantalla
void RenderText(Shader& s, std::string text, GLfloat x, GLfloat y, GLfloat scale, glm::vec3 color);

// Función para cargar una textura desde un archivo especificado en la ruta
unsigned int loadTexture(char const* path);

// Función para cargar un cubemap utilizando una lista de rutas de imágenes
unsigned int loadCubemap(std::vector<std::string> faces);

// Función para mostrar la información del planeta
void ShowInfo(Shader& s);

// Función para obtener la resolución de la pantalla del escritorio
void GetDesktopResolution(float& horizontal, float& vertical)
{
	RECT desktop; // Estructura para almacenar las coordenadas del área de la pantalla
	// Obtener un handle para la ventana del escritorio
	const HWND hDesktop = GetDesktopWindow();
	// Obtener las dimensiones de la ventana del escritorio y almacenarlas en la estructura desktop
	GetWindowRect(hDesktop, &desktop);
	// El rincón superior izquierdo tendrá coordenadas (0,0)
	// y el rincón inferior derecho tendrá coordenadas (horizontal, vertical)
	horizontal = desktop.right; // Establece el valor de ancho de la pantalla
	vertical = desktop.bottom;  // Establece el valor de alto de la pantalla
}


// Tiempo delta para calcular el tiempo transcurrido entre los frames
GLfloat deltaTime = 0.0f;

// Tiempo del último frame para calcular el tiempo transcurrido entre los frames
GLfloat lastFrame = 0.0f;

// Creación de la cámara en la posición (0.0f, 0.0f, 3.0f)
Camera camera(glm::vec3(0.0f, 0.0f, 3.0f));

// Bandera para indicar si la cámara está rotando
bool onRotate = false;

// Bandera para indicar si la cámara está en modo "FreeCam" (cámara libre)
bool onFreeCam = true;

// Bandera para activar o desactivar un "SkyBoxExtra"
bool SkyBoxExtra = false;

// Dimensiones de la ventana de la pantalla (ancho y alto)
float SCREEN_WIDTH = 800, SCREEN_HEIGHT = 600;

// Posición de un punto en el espacio 3D (por defecto, en el origen)
glm::vec3 point = glm::vec3(0.0f, 0.0f, 0.0f);

// Posición de un planeta en el espacio 3D (por defecto, en el origen)
glm::vec3 PlanetPos = glm::vec3(0.0f, 0.0f, 0.0f);

// Últimas coordenadas del mouse, inicializadas al centro de la pantalla
GLfloat lastX = (GLfloat)(SCREEN_WIDTH / 2.0);
GLfloat lastY = (GLfloat)(SCREEN_HEIGHT / 2.0);

// Velocidad del planeta para su movimiento
float PlanetaVelocidad = .1f;

// Identificador del planeta que se está visualizando (inicializado a 0)
int PlanetVista = 0;

// Arreglo para almacenar las teclas presionadas
bool teclas[1024];

// Ángulos de rotación de la escena en los ejes Y y X
GLfloat RotacionY = 0.0f;
GLfloat RotacionX = 0.0f;

// Bandera para indicar si el usuario está en la vista de un planeta
bool onPlanet = false;


// Callback que se ejecuta cada vez que se presiona o suelta una tecla
void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)
{
	// Verifica si se presiona la tecla ESC
	if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
		glfwSetWindowShouldClose(window, GL_TRUE); // Cierra la ventana si se presiona ESC
}


bool firstMouse = true;
GLfloat xoff = 0.0f, yoff = 0.0f;

struct Character {
	GLuint TextureID;   // ID handle of the glyph texture
	glm::ivec2 Size;    // Size of glyph
	glm::ivec2 Bearing;  // Offset from baseline to left/top of glyph
	GLuint Advance;    // Horizontal offset to advance to next glyph
};
std::map<GLchar, Character> Characters;
GLuint textVAO, textVBO;

struct PlanetInfo {
	std::string Name;
	std::string OrbitSpeed;
	std::string Mass;
	std::string Gravity;
};
PlanetInfo Info;

// Callback que se ejecuta cuando el mouse se mueve
void mouse_callback(GLFWwindow* window, double xpos, double ypos)
{
	// Si es el primer movimiento del mouse, inicializa las variables de posición
	if (firstMouse)
	{
		lastX = (GLfloat)xpos; // Guarda la posición actual en X como la última posición
		lastY = (GLfloat)ypos; // Guarda la posición actual en Y como la última posición
		firstMouse = false;    // Indica que ya no es el primer movimiento
	}

}

// Callback que se ejecuta cuando se detecta un desplazamiento de la rueda del mouse
void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
{
	// Si el desplazamiento en Y es positivo (rueda hacia adelante)
	if (yoffset == 1)
		camera.ProcessKeyboard(SCROLL_FORWARD, deltaTime); // Procesa el movimiento hacia adelante en la cámara
	else
	{
		// Si el desplazamiento en Y es negativo o no es 1 (rueda hacia atrás)
		camera.ProcessKeyboard(SCROLL_BACKWARD, deltaTime); // Procesa el movimiento hacia atrás en la cámara
	}
}
// Callback que se ejecuta cuando se presiona o suelta un botón del mouse
void mouse_button_callback(GLFWwindow* window, int button, int action, int mods)
{
	// Verifica si está activada la cámara libre y la cámara aún no está en modo libre
	if (onFreeCam && !camera.FreeCam)
	{
		// Si se presiona el botón derecho del mouse
		if (button == GLFW_MOUSE_BUTTON_RIGHT && action == GLFW_PRESS)
			onRotate = true; // Activa la rotación de la escena
		else
			onRotate = false; // Desactiva la rotación de la escena
	}
}


int main() {
	// Llama a la función GetDesktopResolution para obtener la resolución de pantalla y establecer el tamaño de la ventana
	GetDesktopResolution(SCREEN_WIDTH, SCREEN_HEIGHT); // get resolution for create window

	// Establece la posición de la cámara para que mire hacia un punto específico (por ejemplo, el centro del sistema solar)
	camera.LookAtPos = point;

	/* Inicialización de GLFW */
	glfwInit(); // Inicializa la librería GLFW

	// Establece la versión principal de OpenGL a la que se debe adherir GLFW (versión 3.3)
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);

	// Establece la versión menor de OpenGL para que sea compatible con la versión 3.3
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);

	// Indica que se utilizará el perfil de OpenGL Core (el más moderno y optimizado)
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

	// Configura la cantidad de muestras (antialiasing) para mejorar la calidad visual de la imagen renderizada
	glfwWindowHint(GLFW_SAMPLES, 4); // 4x antialiasing
	/* Finaliza la configuración inicial de GLFW */


	/* CREACIÓN DE LA VENTANA DE GLFW */

// Crea una nueva ventana GLFW con el tamaño especificado y el nombre "LearnOpenGL"
// Usa el monitor principal del sistema para mostrar la ventana
	GLFWwindow* window = glfwCreateWindow(SCREEN_WIDTH, SCREEN_HEIGHT, "LearnOpenGL", glfwGetPrimaryMonitor(), NULL);

	// Verifica si la ventana no se creó correctamente
	if (window == NULL)
	{
		// Si la ventana no se pudo crear, imprime un mensaje de error
		std::cout << "Failed to create GLFW window" << std::endl;

		// Finaliza GLFW
		glfwTerminate();

		// Termina el programa con un código de error
		return -1;
	}

	// Establece el contexto de OpenGL de la ventana como el actual
	glfwMakeContextCurrent(window);

	// Configura los callbacks para manejar el cambio de tamaño de la ventana
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

	// Configura el callback para manejar el movimiento del ratón
	glfwSetCursorPosCallback(window, mouse_callback);

	// Configura el callback para manejar las teclas presionadas
	glfwSetKeyCallback(window, key_callback);

	// Configura el callback para manejar el desplazamiento del ratón (scroll)
	glfwSetScrollCallback(window, scroll_callback);

	// Configura el callback para manejar los clics del ratón
	glfwSetMouseButtonCallback(window, mouse_button_callback);

	/* FIN DE LA CREACIÓN DE LA VENTANA DE GLFW */


	/* LOAD GLAD */
	// Intenta cargar los procedimientos de OpenGL usando GLAD a través de las direcciones de función proporcionadas por GLFW
	if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
	{
		// Si GLAD no pudo inicializarse, imprime un mensaje de error
		std::cout << "No se ha podido inicializar GLAD" << std::endl;

		// Termina el programa con un código de error
		return -1;
	}

	/* LOAD GLAD */


	/* CONFIGURATION FOR TEXT RENDER */
	// Declara una variable para la biblioteca FreeType
	FT_Library ft;

	// Inicializa la biblioteca FreeType y verifica si la inicialización fue exitosa
	if (FT_Init_FreeType(&ft))
		// Si la inicialización falla, imprime un mensaje de error en la consola
		std::cout << "ERROR::FREETYPE: No se ha podido iniciar la librería FreeType" << std::endl;

	// Declara una variable para la cara del tipo de letra (fuente)
	FT_Face face;

	// Intenta cargar la fuente desde el archivo especificado y verifica si fue exitoso
	if (FT_New_Face(ft, "fonts/ff.otf", 0, &face))
		// Si falla al cargar la fuente, imprime un mensaje de error en la consola
		std::cout << "ERROR::FREETYPE: Fallo al cargar fuente" << std::endl;

	// Set size to load glyphs as
	FT_Set_Pixel_Sizes(face, 0, 48);

	// Disable byte-alignment restriction
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

	// Load first 128 characters of ASCII set
	// Itera sobre todos los caracteres ASCII posibles (0-127)
	for (GLubyte c = 0; c < 128; c++)
	{
		// Carga el glifo del carácter actual usando FreeType
		if (FT_Load_Char(face, c, FT_LOAD_RENDER))
		{
			// Si falla al cargar el glifo, imprime un mensaje de error y continúa con el siguiente carácter
			std::cout << "ERROR::FREETYTPE: Falla en cargar glifo" << std::endl;
			continue;
		}

		// Genera una nueva textura para el carácter cargado
		GLuint texture;
		glGenTextures(1, &texture);
		glBindTexture(GL_TEXTURE_2D, texture);

		// Carga la imagen del glifo en la textura
		glTexImage2D(
			GL_TEXTURE_2D,                            // Tipo de textura
			0,                                        // Nivel de la textura (mipmap)
			GL_RED,                                   // Formato de color
			face->glyph->bitmap.width,                // Ancho de la imagen del glifo
			face->glyph->bitmap.rows,                 // Alto de la imagen del glifo
			0,                                        // Sin borde
			GL_RED,                                   // Formato de color de la imagen
			GL_UNSIGNED_BYTE,                         // Tipo de datos de la imagen
			face->glyph->bitmap.buffer                // Datos del glifo
		);

		// Establece las opciones de la textura para que se ajuste correctamente
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);   // Sin repetir la textura en el eje horizontal
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);   // Sin repetir la textura en el eje vertical
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);      // Interpolación lineal para la reducción de la textura
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);      // Interpolación lineal para la ampliación de la textura

		// Almacena el carácter junto con sus detalles para uso posterior
		Character character = {
			texture,                                                   // ID de la textura
			glm::ivec2(face->glyph->bitmap.width, face->glyph->bitmap.rows),  // Tamaño del glifo (ancho, alto)
			glm::ivec2(face->glyph->bitmap_left, face->glyph->bitmap_top),    // Desplazamiento de la textura desde la posición base
			face->glyph->advance.x                                        // Avance del glifo (distancia a la siguiente letra)
		};

		// Inserta el carácter y sus detalles en el mapa de caracteres
		Characters.insert(std::pair<GLchar, Character>(c, character));
	}


	glBindTexture(GL_TEXTURE_2D, 0);
	// Destruir FreeType una vez que hayamos terminado
	FT_Done_Face(face);
	FT_Done_FreeType(ft);
	/* CONFIGURACIÓN PARA LA REPRESENTACIÓN DE TEXTO */


	glEnable(GL_DEPTH_TEST);
	glEnable(GL_MULTISAMPLE);
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	/* SOMBRILLAS */
	Shader SimpleShader("simpleVS.vs", "simpleFS.fs");
	Shader SkyboxShader("skybox.vs", "skybox.fs");
	Shader texShader("simpleVS.vs", "texFS.fs");
	Shader TextShader("TextShader.vs", "TextShader.fs");
	/* SOMBRILLAS */

	// PROYECCIÓN DE TEXTO
	// Crea una matriz de proyección ortográfica para el texto, que asegura que el texto se dibuje en coordenadas de píxeles de la pantalla
	glm::mat4 Text_projection = glm::ortho(0.0f, SCREEN_WIDTH, 0.0f, SCREEN_HEIGHT);
	// Activa el shader de texto
	TextShader.Use();
	// Pasa la matriz de proyección al shader de texto, asociando el valor de la matriz con el uniforme "projection" en el shader
	glUniformMatrix4fv(glGetUniformLocation(TextShader.ID, "projection"), 1, GL_FALSE, glm::value_ptr(Text_projection));



	float cube[] = {
		-0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
		 0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
		 0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
		 0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
		-0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
		-0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

		-0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
		 0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
		 0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
		 0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
		-0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
		-0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

		-0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
		-0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
		-0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
		-0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
		-0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
		-0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

		 0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
		 0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
		 0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
		 0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
		 0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
		 0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

		-0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
		 0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
		 0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
		 0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
		-0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
		-0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

		-0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
		 0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
		 0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
		 0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
		-0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
		-0.5f,  0.5f, -0.5f,  0.0f, 1.0f
	};
	float skyboxVertices[] = {
		// positions          
		-1.0f,  1.0f, -1.0f,
		-1.0f, -1.0f, -1.0f,
		 1.0f, -1.0f, -1.0f,
		 1.0f, -1.0f, -1.0f,
		 1.0f,  1.0f, -1.0f,
		-1.0f,  1.0f, -1.0f,

		-1.0f, -1.0f,  1.0f,
		-1.0f, -1.0f, -1.0f,
		-1.0f,  1.0f, -1.0f,
		-1.0f,  1.0f, -1.0f,
		-1.0f,  1.0f,  1.0f,
		-1.0f, -1.0f,  1.0f,

		 1.0f, -1.0f, -1.0f,
		 1.0f, -1.0f,  1.0f,
		 1.0f,  1.0f,  1.0f,
		 1.0f,  1.0f,  1.0f,
		 1.0f,  1.0f, -1.0f,
		 1.0f, -1.0f, -1.0f,

		-1.0f, -1.0f,  1.0f,
		-1.0f,  1.0f,  1.0f,
		 1.0f,  1.0f,  1.0f,
		 1.0f,  1.0f,  1.0f,
		 1.0f, -1.0f,  1.0f,
		-1.0f, -1.0f,  1.0f,

		-1.0f,  1.0f, -1.0f,
		 1.0f,  1.0f, -1.0f,
		 1.0f,  1.0f,  1.0f,
		 1.0f,  1.0f,  1.0f,
		-1.0f,  1.0f,  1.0f,
		-1.0f,  1.0f, -1.0f,

		-1.0f, -1.0f, -1.0f,
		-1.0f, -1.0f,  1.0f,
		 1.0f, -1.0f, -1.0f,
		 1.0f, -1.0f, -1.0f,
		-1.0f, -1.0f,  1.0f,
		 1.0f, -1.0f,  1.0f
	};

	/* GENERACIÓN DE SKYBOX */
	unsigned int skyboxVAO, skyboxVBO;
	glGenVertexArrays(1, &skyboxVAO);
	glGenBuffers(1, &skyboxVBO);
	glBindVertexArray(skyboxVAO);
	glBindBuffer(GL_ARRAY_BUFFER, skyboxVBO);
	glBufferData(GL_ARRAY_BUFFER, sizeof(skyboxVertices), &skyboxVertices, GL_STATIC_DRAW);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
	/* GENERACIÓN DE SKYBOX */

	/* GENERACIÓN DE VÉRTICES PARA ÓRBITAS */
	std::vector<float> orbVert;
	GLfloat xx;
	GLfloat zz;
	float angl;
	for (int i = 0; i < 2000; i++)
	{
		angl = (float)(M_PI / 2 - i * (M_PI / 1000));
		xx = sin(angl) * 100.0f;
		zz = cos(angl) * 100.0f;
		orbVert.push_back(xx);
		orbVert.push_back(0.0f);
		orbVert.push_back(zz);

	}
	/* GENERACIÓN DE VÉRTICES PARA ÓRBITAS */

	/* VAO-VBO para ORBITAS*/
	// Declara las variables para el VBO (Vertex Buffer Object) y VAO (Vertex Array Object) de texto
	GLuint VBO_t, VAO_t;
	// Genera un VAO para almacenar el estado de los vértices
	glGenVertexArrays(1, &VAO_t);
	// Genera un VBO para almacenar los datos del vértice
	glGenBuffers(1, &VBO_t);
	// Activa el VAO para que las siguientes configuraciones se almacenen en él
	glBindVertexArray(VAO_t);
	// Activa el VBO y lo asocia al buffer de vértices
	glBindBuffer(GL_ARRAY_BUFFER, VBO_t);
	// Copia los datos del vértice (almacenados en orbVert) al VBO, usando un buffer estático
	glBufferData(GL_ARRAY_BUFFER, sizeof(float)* orbVert.size(), orbVert.data(), GL_STATIC_DRAW);
	// Establece cómo se deben interpretar los datos del VBO en el shader (en este caso, como atributos de 3 componentes flotantes)
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);
	// Habilita el uso del atributo de vértices (en este caso, el atributo 0)
	glEnableVertexAttribArray(0);
	// Desvincula el VBO, ya que no es necesario continuar modificándolo
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	// Desvincula el VAO, finalizando su configuración
	glBindVertexArray(0);
	/* VAO-VBO para ORBITAS*/

	/* REPRESENTACIÓN DE TEXTO VAO-VBO*/
	glGenVertexArrays(1, &textVAO);
	glGenBuffers(1, &textVBO);
	glBindVertexArray(textVAO);
	glBindBuffer(GL_ARRAY_BUFFER, textVBO);
	glBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * 6 * 4, NULL, GL_DYNAMIC_DRAW);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(GLfloat), 0);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindVertexArray(0);
	/* REPRESENTACIÓN DE TEXTO VAO-VBO*/

	/* TEXTURAS - CARGAR PLANETAS */
	unsigned int texture_earth = loadTexture("resources/planets/earth2k.jpg");
	unsigned int t_sun = loadTexture("resources/planets/2k_sun.jpg");
	unsigned int texture_moon = loadTexture("resources/planets/2k_moon.jpg");
	unsigned int texture_mercury = loadTexture("resources/planets/2k_mercury.jpg");
	unsigned int texture_venus = loadTexture("resources/planets/2k_mercury.jpg");
	unsigned int texture_mars = loadTexture("resources/planets/2k_mars.jpg");
	unsigned int texture_jupiter = loadTexture("resources/planets/2k_jupiter.jpg");
	unsigned int texture_saturn = loadTexture("resources/planets/2k_saturn.jpg");
	unsigned int texture_uranus = loadTexture("resources/planets/2k_uranus.jpg");
	unsigned int texture_neptune = loadTexture("resources/planets/2k_neptune.jpg");
	unsigned int texture_saturn_ring = loadTexture("resources/planets/r.jpg");
	unsigned int texture_earth_clouds = loadTexture("resources/planets/2k_earth_clouds.jpg");
	/* TEXTURAS - CARGAR PLANETAS */

	/* GENERACIÓN DE ESFERA PARA CADA PLANETA */
	Sphere Sun(100.0f, 36 * 5, 18 * 5);
	Sphere Mercury(10.0f, 36, 18);
	Sphere Venus(12.0f, 36, 18);
	Sphere Earth(11.8f, 36, 18);
	Sphere Mars(8.0f, 36, 18);
	Sphere Jupiter(40.0f, 36, 18);
	Sphere Saturn(37.0f, 36, 18);
	Sphere Uranus(30.0f, 36, 18);
	Sphere Neptune(30.0f, 36, 19);
	Sphere Moon(5.5f, 36, 18);
	/* GENERACIÓN DE ESFERA PARA CADA PLANETA */

	std::vector<std::string> faces
	{
		"resources/skybox/starfield/starfield_rt.tga",
		"resources/skybox/starfield/starfield_lf.tga",
		"resources/skybox/starfield/starfield_up.tga",
		"resources/skybox/starfield/starfield_dn.tga",
		"resources/skybox/starfield/starfield_ft.tga",
		"resources/skybox/starfield/starfield_bk.tga",
	};
	std::vector<std::string> faces_extra
	{
		"resources/skybox/blue/bkg1_right.png",
		"resources/skybox/blue/bkg1_left.png",
		"resources/skybox/blue/bkg1_top.png",
		"resources/skybox/blue/bkg1_bot.png",
		"resources/skybox/blue/bkg1_front.png",
		"resources/skybox/blue/bkg1_back.png",
	};

	unsigned int cubemapTexture = loadCubemap(faces);
	unsigned int cubemapTextureExtra = loadCubemap(faces_extra);
	GLfloat camX = 10.0f;
	GLfloat camZ = 10.0f;

	camera.Position = glm::vec3(0.0f, 250.0f, -450.0f);
	camera.Yaw = 90.0f;
	camera.Pitch = -40.0f;
	camera.ProcessMouseMovement(xoff, yoff);
	camera.FreeCam = false;
	onFreeCam = true;
	glm::mat4 view;
	glm::vec3 PlanetsPositions[9];
	while (!glfwWindowShouldClose(window))
	{
		// Obtiene el tiempo actual desde que la aplicación inició, en segundos
		GLfloat currentFrame = (GLfloat)glfwGetTime();
		// Calcula el tiempo transcurrido entre el último cuadro y el cuadro actual
		deltaTime = currentFrame - lastFrame;
		// Actualiza el tiempo del último cuadro al tiempo actual
		lastFrame = currentFrame;

		/* CONTROL DEL ZOOM */
		// Verifica si la cámara no está en modo de cámara libre
		if (!camera.FreeCam)
		{
			// Ajusta la velocidad de movimiento de la cámara dependiendo de su posición en el eje Y
			if (camera.Position.y < 200 && camera.Position.y > 200.0f) // Posición alrededor de 200
				camera.MovementSpeed = 300.0f; // Establece la velocidad de movimiento a 300.0f

			if (camera.Position.y < 125.f && camera.Position.y > 70.0f) // Posición entre 70 y 125
				camera.MovementSpeed = 200.0f; // Establece la velocidad de movimiento a 200.0f

			if (camera.Position.y < 70.f && camera.Position.y > 50.0f) // Posición entre 50 y 70
				camera.MovementSpeed = 100.0f; // Establece la velocidad de movimiento a 100.0f

			if (camera.Position.y > 200 && camera.Position.y < 400.0f) // Posición entre 200 y 400
				camera.MovementSpeed = 400.0f; // Establece la velocidad de movimiento a 400.0f

			if (camera.Position.y > 125.f && camera.Position.y < 200.0f) // Posición entre 125 y 200
				camera.MovementSpeed = 300.0f; // Establece la velocidad de movimiento a 300.0f

			if (camera.Position.y > 70.f && camera.Position.y < 125.0f) // Posición entre 70 y 125
				camera.MovementSpeed = 200.0f; // Establece la velocidad de movimiento a 200.0f
		}

		/* CONTROL DEL ZOOM */
		processInput(window); // Procesa las entradas del usuario a través del teclado y mouse
		// Verifica si no está activado el modo de cámara libre
		if (!onFreeCam)
		{
			RotacionY = 0.0f; // Reinicia la rotación en el eje Y de la escena
			RotacionX = 0.0f; // Reinicia la rotación en el eje X de la escena
		}

		// Si la cámara está en modo libre o hay un planeta seleccionado
		if (camera.FreeCam || PlanetVista > 0)
			glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // Oculta el cursor y lo centra en la ventana
		else
			glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL); // Muestra el cursor y permite su movimiento normal

		// renderizar
		glClearColor(1.0f, 1.0f, 1.0f, 1.0f); // Establece el color de limpieza del buffer a blanco (RGBA: 1.0, 1.0, 1.0, 1.0)
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Limpia los buffers de color y profundidad para preparar el renderizado

		SimpleShader.Use(); // Activa el shader `SimpleShader` para su uso en el renderizado

		glm::mat4 model = glm::mat4(1.0f); // Crea una matriz de modelo de identidad para inicializar transformaciones

		double viewX; // Declara una variable para la posición X de la vista
		double viewZ; // Declara una variable para la posición Z de la vista
		glm::vec3 viewPos; // Declara un vector para la posición de la cámara en el espacio de vista

		SimpleShader.Use(); // Asegura que `SimpleShader` esté activo antes de configurar matrices
		glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCREEN_WIDTH / (float)SCREEN_HEIGHT, 0.1f, 10000.0f);
		// Configura la matriz de proyección para una perspectiva con campo de visión, proporción de aspecto, distancia cercana y lejana

		SimpleShader.setMat4("model", model); // Pasa la matriz de modelo al shader
		SimpleShader.setMat4("view", view); // Pasa la matriz de vista al shader
		SimpleShader.setMat4("projection", projection); // Pasa la matriz de proyección al shader

		glActiveTexture(GL_TEXTURE0); // Activa la unidad de textura 0 para su uso
		glBindTexture(GL_TEXTURE_2D, t_sun); // Vincula la textura del sol (`t_sun`) para el renderizado

		/* SOL */
		glm::mat4 model_sun; // Declara una matriz de modelo para representar las transformaciones del sol
		model_sun = glm::rotate(model_sun, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		// Aplica una rotación de -90 grados alrededor del eje X para ajustar la orientación del sol
		model_sun = glm::rotate(model_sun, (GLfloat)glfwGetTime() * glm::radians(23.5f) * 0.25f, glm::vec3(0.0f, 0.0f, 1.f));
		// Aplica una rotación continua basada en el tiempo alrededor del eje Z para simular la inclinación del eje
		model_sun = glm::translate(model_sun, point);
		// Traduce el modelo del sol a las coordenadas especificadas por `point`
		SimpleShader.setMat4("model", model_sun);
		// Establece la matriz de modelo transformada en el shader activo
		Sun.Draw();
		// Renderiza el modelo del sol usando el shader y las transformaciones actuales
		/* SOL */


		/* MERCURIO  */
		glm::mat4 model_mercury; // Declara una matriz de modelo para las transformaciones de Mercurio

		double xx = sin(glfwGetTime() * PlanetaVelocidad) * 100.0f * 2.0f * 1.3f;
		// Calcula la posición X de Mercurio basado en una órbita circular y el tiempo transcurrido

		double zz = cos(glfwGetTime() * PlanetaVelocidad) * 100.0f * 2.0f * 1.3f;
		// Calcula la posición Z de Mercurio usando la función coseno para mantener la órbita circular

		glActiveTexture(GL_TEXTURE0);
		// Activa la unidad de textura 0 para el siguiente uso

		glBindTexture(GL_TEXTURE_2D, texture_mercury);
		// Enlaza la textura de Mercurio a la unidad de textura activa

		model_mercury = glm::translate(model_mercury, point);
		// Mueve el modelo de Mercurio a la posición inicial `point`

		model_mercury = glm::rotate(model_mercury, glm::radians(RotacionY), glm::vec3(1.0f, 0.0f, 0.0f));
		// Rota el modelo alrededor del eje X basado en el ángulo `SceneRotateY`

		model_mercury = glm::rotate(model_mercury, glm::radians(RotacionX), glm::vec3(0.0f, 0.0f, 1.0f));
		// Rota el modelo alrededor del eje Z basado en el ángulo `SceneRotateX`

		model_mercury = glm::translate(model_mercury, glm::vec3(xx, 0.0f, zz));
		// Traduce el modelo a la posición calculada para la órbita de Mercurio

		PlanetsPositions[0] = glm::vec3(xx, 0.0f, zz);
		// Almacena la posición actual de Mercurio en el arreglo de posiciones de planetas

		model_mercury = glm::rotate(model_mercury, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		// Rota el modelo -90 grados alrededor del eje X para ajustar su orientación inicial

		model_mercury = glm::rotate(model_mercury, (GLfloat)glfwGetTime() * glm::radians(-90.0f) * 0.05f, glm::vec3(0.0f, 0.0f, 1.f));
		// Aplica una rotación continua en el tiempo para simular la rotación de Mercurio sobre su eje

		SimpleShader.setMat4("model", model_mercury);
		// Establece la matriz de modelo transformada en el shader activo

		Mercury.Draw();
		// Renderiza el modelo de Mercurio usando el shader y las transformaciones actuales
		/* MERCURIO  */


		/* VENUS */
		glm::mat4 model_venus;
		xx = sin(glfwGetTime() * PlanetaVelocidad * 0.75f) * 100.0f * 3.0f * 1.3f;
		zz = cos(glfwGetTime() * PlanetaVelocidad * 0.75f) * 100.0f * 3.0f * 1.3f;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_venus);
		model_venus = glm::translate(model_venus, point);
		model_venus = glm::rotate(model_venus, glm::radians(RotacionY), glm::vec3(1.0f, 0.0f, 0.0f));
		model_venus = glm::rotate(model_venus, glm::radians(RotacionX), glm::vec3(0.0f, 0.0f, 1.0f));
		model_venus = glm::translate(model_venus, glm::vec3(xx, 0.0f, zz));
		PlanetsPositions[1] = glm::vec3(xx, 0.0f, zz);
		model_venus = glm::rotate(model_venus, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_venus = glm::rotate(model_venus, glm::radians(-132.5f), glm::vec3(0.0f, 1.0f, 0.f));
		model_venus = glm::rotate(model_venus, (GLfloat)glfwGetTime() * glm::radians(-132.5f) * 0.012f, glm::vec3(0.0f, 0.0f, 1.f));
		SimpleShader.setMat4("model", model_venus);
		Venus.Draw();
		/* VENUS */

		/* TIERRA */
		glm::mat4 model_earth;
		xx = sin(glfwGetTime() * PlanetaVelocidad * 0.55f) * 100.0f * 4.0f * 1.3f;
		zz = cos(glfwGetTime() * PlanetaVelocidad * 0.55f) * 100.0f * 4.0f * 1.3f;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_earth);
		model_earth = glm::translate(model_earth, point);
		model_earth = glm::rotate(model_earth, glm::radians(RotacionY), glm::vec3(1.0f, 0.0f, 0.0f));
		model_earth = glm::rotate(model_earth, glm::radians(RotacionX), glm::vec3(0.0f, 0.0f, 1.0f));
		model_earth = glm::translate(model_earth, glm::vec3(xx, 0.0f, zz));
		glm::vec3 EarthPoint = glm::vec3(xx, 0.0f, zz);
		PlanetsPositions[2] = glm::vec3(xx, 0.0f, zz);
		model_earth = glm::rotate(model_earth, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_earth = glm::rotate(model_earth, glm::radians(-33.25f), glm::vec3(0.0f, 1.0f, 0.f));
		model_earth = glm::rotate(model_earth, (GLfloat)glfwGetTime() * glm::radians(-33.25f) * 2.0f, glm::vec3(0.0f, 0.0f, 1.f));
		camera.LookAtPos = glm::vec3(model_earth[3][0], model_earth[3][1], model_earth[3][2]);
		SimpleShader.setMat4("model", model_earth);
		Earth.Draw();
		/* TIERRA */

		/* LUNA */
		glm::mat4 model_moon;
		xx = sin(glfwGetTime() * PlanetaVelocidad * 67.55f) * 100.0f * 0.5f * 1.3f;
		zz = cos(glfwGetTime() * PlanetaVelocidad * 67.55f) * 100.0f * 0.5f * 1.3f;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_moon);
		model_moon = glm::rotate(model_moon, glm::radians(RotacionY), glm::vec3(1.0f, 0.0f, 0.0f));
		model_moon = glm::rotate(model_moon, glm::radians(RotacionX), glm::vec3(0.0f, 0.0f, 1.0f));
		model_moon = glm::translate(model_moon, EarthPoint);
		model_moon = glm::translate(model_moon, glm::vec3(xx, 0.0f, zz));
		model_moon = glm::rotate(model_moon, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_moon = glm::rotate(model_moon, glm::radians(-32.4f), glm::vec3(0.0f, 1.0f, 0.f));
		model_moon = glm::rotate(model_moon, (GLfloat)glfwGetTime() * glm::radians(-32.4f) * 3.1f, glm::vec3(0.0f, 0.0f, 1.f));
		SimpleShader.setMat4("model", model_moon);
		Moon.Draw();
		/* LUNA */


		/* MARTE */
		glm::mat4 model_mars;
		xx = sin(glfwGetTime() * PlanetaVelocidad * 0.35f) * 100.0f * 5.0f * 1.3f;
		zz = cos(glfwGetTime() * PlanetaVelocidad * 0.35f) * 100.0f * 5.0f * 1.3f;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_mars);
		model_mars = glm::translate(model_mars, point);
		model_mars = glm::rotate(model_mars, glm::radians(RotacionY), glm::vec3(1.0f, 0.0f, 0.0f));
		model_mars = glm::rotate(model_mars, glm::radians(RotacionX), glm::vec3(0.0f, 0.0f, 1.0f));
		model_mars = glm::translate(model_mars, glm::vec3(xx, 0.0f, zz));
		PlanetsPositions[3] = glm::vec3(xx, 0.0f, zz);
		model_mars = glm::rotate(model_mars, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_mars = glm::rotate(model_mars, glm::radians(-32.4f), glm::vec3(0.0f, 1.0f, 0.f));
		model_mars = glm::rotate(model_mars, (GLfloat)glfwGetTime() * glm::radians(-32.4f) * 2.1f, glm::vec3(0.0f, 0.0f, 1.f));
		SimpleShader.setMat4("model", model_mars);
		Mars.Draw();
		/* MARTE */

		/* JÚPITER */
		glm::mat4 model_jupiter;
		xx = sin(glfwGetTime() * PlanetaVelocidad * 0.2f) * 100.0f * 6.0f * 1.3f;
		zz = cos(glfwGetTime() * PlanetaVelocidad * 0.2f) * 100.0f * 6.0f * 1.3f;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_jupiter);
		model_jupiter = glm::translate(model_jupiter, point);
		model_jupiter = glm::rotate(model_jupiter, glm::radians(RotacionY), glm::vec3(1.0f, 0.0f, 0.0f));
		model_jupiter = glm::rotate(model_jupiter, glm::radians(RotacionX), glm::vec3(0.0f, 0.0f, 1.0f));
		model_jupiter = glm::translate(model_jupiter, glm::vec3(xx, 0.0f, zz));
		PlanetsPositions[4] = glm::vec3(xx, 0.0f, zz);
		model_jupiter = glm::rotate(model_jupiter, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_jupiter = glm::rotate(model_jupiter, glm::radians(-23.5f), glm::vec3(0.0f, 1.0f, 0.f));
		model_jupiter = glm::rotate(model_jupiter, (GLfloat)glfwGetTime() * glm::radians(-23.5f) * 4.5f, glm::vec3(0.0f, 0.0f, 1.f));
		SimpleShader.setMat4("model", model_jupiter);
		Jupiter.Draw();
		/* JÚPITER */

		/* SATURNO */
		glm::mat4 model_saturn;
		xx = sin(glfwGetTime() * PlanetaVelocidad * 0.15f) * 100.0f * 7.0f * 1.3f;
		zz = cos(glfwGetTime() * PlanetaVelocidad * 0.15f) * 100.0f * 7.0f * 1.3f;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_saturn);
		model_saturn = glm::translate(model_saturn, point);
		model_saturn = glm::rotate(model_saturn, glm::radians(RotacionY), glm::vec3(1.0f, 0.0f, 0.0f));
		model_saturn = glm::rotate(model_saturn, glm::radians(RotacionX), glm::vec3(0.0f, 0.0f, 1.0f));
		model_saturn = glm::translate(model_saturn, glm::vec3(xx, 0.0f, zz));
		glm::vec3 SatrunPoint = glm::vec3(xx, 0.0f, zz);
		PlanetsPositions[5] = glm::vec3(xx, 0.0f, zz);
		model_saturn = glm::rotate(model_saturn, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_saturn = glm::rotate(model_saturn, glm::radians(-34.7f), glm::vec3(0.0f, 1.0f, 0.f));
		model_saturn = glm::rotate(model_saturn, (GLfloat)glfwGetTime() * glm::radians(-34.7f) * 4.48f, glm::vec3(0.0f, 0.0f, 1.f));
		SimpleShader.setMat4("model", model_saturn);
		Saturn.Draw();
		/* SATURNO */

		/* URANO */
		glm::mat4 model_uranus;
		xx = sin(glfwGetTime() * PlanetaVelocidad * 0.1f) * 100.0f * 8.0f * 1.3f;
		zz = cos(glfwGetTime() * PlanetaVelocidad * 0.1f) * 100.0f * 8.0f * 1.3f;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_uranus);
		model_uranus = glm::translate(model_uranus, point);
		model_uranus = glm::rotate(model_uranus, glm::radians(RotacionY), glm::vec3(1.0f, 0.0f, 0.0f));
		model_uranus = glm::rotate(model_uranus, glm::radians(RotacionX), glm::vec3(0.0f, 0.0f, 1.0f));
		model_uranus = glm::translate(model_uranus, glm::vec3(xx, 0.0f, zz));
		PlanetsPositions[6] = glm::vec3(xx, 0.0f, zz);
		model_uranus = glm::rotate(model_uranus, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_uranus = glm::rotate(model_uranus, glm::radians(-99.0f), glm::vec3(0.0f, 1.0f, 0.f));
		model_uranus = glm::rotate(model_uranus, (GLfloat)glfwGetTime() * glm::radians(-99.0f) * 4.5f, glm::vec3(0.0f, 0.0f, 1.f));
		SimpleShader.setMat4("model", model_uranus);
		Uranus.Draw();
		/* URANO */

		/* NEPTUNO */
		glm::mat4 model_neptune;
		xx = sin(glfwGetTime() * PlanetaVelocidad * 0.08f) * 100.0f * 9.0f * 1.3f;
		zz = cos(glfwGetTime() * PlanetaVelocidad * 0.08f) * 100.0f * 9.0f * 1.3f;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_neptune);

		model_neptune = glm::translate(model_neptune, point);
		model_neptune = glm::rotate(model_neptune, glm::radians(RotacionY), glm::vec3(1.0f, 0.0f, 0.0f));
		model_neptune = glm::rotate(model_neptune, glm::radians(RotacionX), glm::vec3(0.0f, 0.0f, 1.0f));
		model_neptune = glm::translate(model_neptune, glm::vec3(xx, 0.0f, zz));
		PlanetsPositions[7] = glm::vec3(xx, 0.0f, zz);
		model_neptune = glm::rotate(model_neptune, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.f));
		model_neptune = glm::rotate(model_neptune, glm::radians(-30.2f), glm::vec3(0.0f, 1.0f, 0.f));
		model_neptune = glm::rotate(model_neptune, (GLfloat)glfwGetTime() * glm::radians(-30.2f) * 4.0f, glm::vec3(0.0f, 0.0f, 1.f));

		SimpleShader.setMat4("model", model_neptune);
		Neptune.Draw();
		/* NEPTUNO */

		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_venus);

		/* ORBITAS */
		glBindVertexArray(VAO_t);		// Enlaza el VAO que contiene la configuración para los vértices del objeto
		glLineWidth(1.0f); 		// Establece el grosor de las líneas que se dibujarán

		glm::mat4 modelorb;		// Declara una matriz de modelo para las transformaciones de las órbitas
		for (float i = 2; i < 10; i++)
		{
			modelorb = glm::mat4(1); 			// Inicializa la matriz de modelo como una identidad
			modelorb = glm::translate(modelorb, point);			// Traduce la matriz al punto central definido
			modelorb = glm::rotate(modelorb, glm::radians(RotacionY), glm::vec3(1.0f, 0.0f, 0.0f));
			// Rota la órbita en el eje X según el ángulo `RotacionY`
			modelorb = glm::rotate(modelorb, glm::radians(RotacionX), glm::vec3(0.0f, 0.0f, 1.0f));
			// Rota la órbita en el eje Z según el ángulo `RotacionX`
			modelorb = glm::scale(modelorb, glm::vec3(i * 1.3f, i * 1.3f, i * 1.3f));
			// Escala la órbita proporcionalmente al índice `i`, simulando órbitas de diferentes tamaños
			SimpleShader.setMat4("model", modelorb);
			// Establece la matriz de modelo transformada en el shader activo
			glDrawArrays(GL_LINE_LOOP, 0, (GLsizei)orbVert.size() / 3);
			// Dibuja las líneas que representan la órbita como un bucle cerrado
		}
		modelorb = glm::mat4(1);
		// Reinicia la matriz de modelo como identidad para la siguiente órbita
		modelorb = glm::rotate(modelorb, glm::radians(RotacionY), glm::vec3(1.0f, 0.0f, 0.0f));
		// Rota la órbita en el eje X según el ángulo `RotacionY`
		modelorb = glm::rotate(modelorb, glm::radians(RotacionX), glm::vec3(0.0f, 0.0f, 1.0f));
		// Rota la órbita en el eje Z según el ángulo `RotacionX`
		modelorb = glm::translate(modelorb, EarthPoint);
		// Traduce la matriz al punto donde se encuentra la Tierra
		modelorb = glm::scale(modelorb, glm::vec3(0.5f * 1.3f, 0.5f * 1.3f, 0.5f * 1.3f));
		// Escala la órbita para que sea proporcional a la escala definida (más pequeña)
		SimpleShader.setMat4("model", modelorb);
		// Establece la matriz de modelo transformada en el shader activo
		glDrawArrays(GL_LINE_LOOP, 0, (GLsizei)orbVert.size() / 3);
		// Dibuja la órbita de la Tierra como un bucle cerrado

		/* ORBITAS */

		/* ANILLOS DE SATURNO */
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_saturn_ring);
		glLineWidth(2.0f);
		GLfloat rr = 0.55f;
		for (int i = 0; i < 25; i++)
		{
			modelorb = glm::mat4(1);

			modelorb = glm::rotate(modelorb, glm::radians(RotacionY), glm::vec3(1.0f, 0.0f, 0.0f));
			modelorb = glm::rotate(modelorb, glm::radians(RotacionX), glm::vec3(0.0f, 0.0f, 1.0f));
			modelorb = glm::translate(modelorb, SatrunPoint);
			modelorb = glm::rotate(modelorb, glm::radians(30.0f), glm::vec3(0.0f, 0.0f, 1.0f));
			modelorb = glm::scale(modelorb, glm::vec3(rr, rr, rr));
			SimpleShader.setMat4("model", modelorb);
			glDrawArrays(GL_LINE_LOOP, 0, (GLsizei)orbVert.size() / 3);
			if (i == 15)
				rr += 0.030f;
			else
				rr += 0.01f;
		}
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_venus);
		glBindVertexArray(0);
		/* ANILLOS DE SATURNO */


		/* DIBUJAR SKYBOX */
		glDepthFunc(GL_LEQUAL);
		// Configura la función de profundidad para permitir que los fragmentos con valores de profundidad iguales o menores sean dibujados
		SkyboxShader.Use();
		// Activa el shader para renderizar el skybox
		view = glm::mat4(glm::mat3(camera.GetViewMatrix()));
		// Convierte la matriz de vista de la cámara en una matriz 3x3 y luego en una 4x4 para eliminar las traslaciones
		SkyboxShader.setMat4("view", view);
		// Establece la matriz de vista transformada en el shader del skybox
		SkyboxShader.setMat4("projection", projection);
		// Establece la matriz de proyección en el shader del skybox
		// skybox cube
		glBindVertexArray(skyboxVAO);
		// Enlaza el VAO que contiene los vértices del cubo del skybox
		glActiveTexture(GL_TEXTURE0);
		// Activa la unidad de textura 0 para trabajar con la textura del skybox
		if (SkyBoxExtra)
			glBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTextureExtra);
		// Si la variable `SkyBoxExtra` está activada, enlaza la textura de cubemap extra al cubo del skybox
		else
			glBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTexture);
		// Si no, enlaza la textura de cubemap predeterminada al cubo del skybox
		glDrawArrays(GL_TRIANGLES, 0, 36);
		// Dibuja el cubo del skybox utilizando triángulos, con 36 vértices (6 caras * 2 triángulos por cara * 3 vértices por triángulo)
		glBindVertexArray(0);
		// Desenlaza el VAO del skybox para evitar modificaciones no deseadas
		glDepthFunc(GL_LESS);
		// Restablece la función de profundidad a su configuración predeterminada para garantizar un renderizado correcto de otros objetos
		/* DIBUJAR SKYBOX */

		/* SEGUIMIENTO DEL PLANETA + MOSTRAR INFORMACIÓN DEL PLANETA */
		switch (PlanetVista)
		{
		case 1:
			viewX = sin(glfwGetTime() * PlanetaVelocidad) * 100.0f * 3.5f * 1.3f;
			viewZ = cos(glfwGetTime() * PlanetaVelocidad) * 100.0f * 3.5f * 1.3f;
			viewPos = glm::vec3(viewX, 50.0f, viewZ);
			view = glm::lookAt(viewPos, PlanetsPositions[0], glm::vec3(0.0f, 1.0f, 0.0f));
			ShowInfo(TextShader);
			break;

		case 2:
			viewX = sin(glfwGetTime() * PlanetaVelocidad * 0.75f) * 100.0f * 4.5f * 1.2f;
			viewZ = cos(glfwGetTime() * PlanetaVelocidad * 0.75f) * 100.0f * 4.5f * 1.2f;
			viewPos = glm::vec3(viewX, 50.0f, viewZ);
			view = glm::lookAt(viewPos, PlanetsPositions[1], glm::vec3(0.0f, 1.0f, 0.0f));
			ShowInfo(TextShader);
			break;

		case 3:
			viewX = sin(glfwGetTime() * PlanetaVelocidad * 0.55f) * 100.0f * 5.5f * 1.2f;
			viewZ = cos(glfwGetTime() * PlanetaVelocidad * 0.55f) * 100.0f * 5.5f * 1.2f;
			viewPos = glm::vec3(viewX, 50.0f, viewZ);
			view = glm::lookAt(viewPos, PlanetsPositions[2], glm::vec3(0.0f, 1.0f, 0.0f));
			ShowInfo(TextShader);
			break;

		case 4:
			viewX = sin(glfwGetTime() * PlanetaVelocidad * 0.35f) * 100.0f * 6.0f * 1.2f;
			viewZ = cos(glfwGetTime() * PlanetaVelocidad * 0.35f) * 100.0f * 6.0f * 1.2f;
			viewPos = glm::vec3(viewX, 20.0f, viewZ);
			view = glm::lookAt(viewPos, PlanetsPositions[3], glm::vec3(0.0f, 1.0f, 0.0f));
			ShowInfo(TextShader);
			break;

		case 5:
			viewX = sin(glfwGetTime() * PlanetaVelocidad * 0.2f) * 100.0f * 7.5f * 1.3f;
			viewZ = cos(glfwGetTime() * PlanetaVelocidad * 0.2f) * 100.0f * 7.5f * 1.3f;
			viewPos = glm::vec3(viewX, 50.0f, viewZ);
			view = glm::lookAt(viewPos, PlanetsPositions[4], glm::vec3(0.0f, 1.0f, 0.0f));
			ShowInfo(TextShader);
			break;

		case 6:
			viewX = sin(glfwGetTime() * PlanetaVelocidad * 0.15f) * 100.0f * 8.5f * 1.3f;
			viewZ = cos(glfwGetTime() * PlanetaVelocidad * 0.15f) * 100.0f * 8.5f * 1.3f;
			viewPos = glm::vec3(viewX, 50.0f, viewZ);
			view = glm::lookAt(viewPos, PlanetsPositions[5], glm::vec3(0.0f, 1.0f, 0.0f));
			ShowInfo(TextShader);
			break;

		case 7:
			viewX = sin(glfwGetTime() * PlanetaVelocidad * 0.1f) * 100.0f * 9.5f * 1.3f;
			viewZ = cos(glfwGetTime() * PlanetaVelocidad * 0.1f) * 100.0f * 9.5f * 1.3f;
			viewPos = glm::vec3(viewX, 50.0f, viewZ);
			view = glm::lookAt(viewPos, PlanetsPositions[6], glm::vec3(0.0f, 1.0f, 0.0f));
			ShowInfo(TextShader);
			break;

		case 8:
			viewX = sin(glfwGetTime() * PlanetaVelocidad * 0.08f) * 100.0f * 10.5f * 1.3f;
			viewZ = cos(glfwGetTime() * PlanetaVelocidad * 0.08f) * 100.0f * 10.5f * 1.3f;
			viewPos = glm::vec3(viewX, 50.0f, viewZ);
			view = glm::lookAt(viewPos, PlanetsPositions[7], glm::vec3(0.0f, 1.0f, 0.0f));
			ShowInfo(TextShader);
			break;

		case 0:
			view = camera.GetViewMatrix();
			// Renderiza el título principal del sistema solar en la esquina superior izquierda
			RenderText(TextShader, "EF_GRUPO11_SISTEMA_SOLAR (AVANCE) ",
				25.0f,                             // Coordenada X (margen izquierdo)
				SCREEN_HEIGHT - 30.0f,             // Coordenada Y (altura de la pantalla menos 30 píxeles)
				0.50f,                             // Escala del texto
				glm::vec3(0.7f, 0.7f, 0.11f));     // Color del texto (amarillo claro)

			// Renderiza el texto "DATOS:" debajo del título principal
			RenderText(TextShader, "DATOS: ",
				25.0f,                             // Coordenada X (margen izquierdo)
				SCREEN_HEIGHT - 55.0f,             // Coordenada Y (altura menos 55 píxeles)
				0.35f,                             // Escala del texto (un poco más pequeño)
				glm::vec3(0.7f, 0.7f, 0.11f));     // Color del texto (amarillo claro)

			// Renderiza información sobre el sol
			RenderText(TextShader, "1    :SOL ",
				25.0f,                             // Coordenada X (margen izquierdo)
				SCREEN_HEIGHT - 80.0f,             // Coordenada Y (altura menos 80 píxeles)
				0.35f,                             // Escala del texto
				glm::vec3(0.7f, 0.7f, 0.11f));     // Color del texto

			// Renderiza información sobre los planetas
			RenderText(TextShader, "8    : PLANETAS ",
				25.0f,                             // Coordenada X
				SCREEN_HEIGHT - 105.0f,            // Coordenada Y (altura menos 105 píxeles)
				0.35f,                             // Escala del texto
				glm::vec3(0.7f, 0.7f, 0.11f));     // Color del texto

			// Renderiza información sobre los satélites
			RenderText(TextShader, "415  : SATELITES ",
				25.0f,                             // Coordenada X
				SCREEN_HEIGHT - 130.0f,            // Coordenada Y (altura menos 130 píxeles)
				0.35f,                             // Escala del texto
				glm::vec3(0.7f, 0.7f, 0.11f));     // Color del texto

			// Renderiza información sobre los cometas
			RenderText(TextShader, "3441 :COMETAS ",
				25.0f,                             // Coordenada X
				SCREEN_HEIGHT - 155.0f,            // Coordenada Y (altura menos 155 píxeles)
				0.35f,                             // Escala del texto
				glm::vec3(0.7f, 0.7f, 0.11f));     // Color del texto

			// Si la cámara está en modo libre, renderiza el texto "CAMARA LIBRE" en la esquina superior derecha
			if (camera.FreeCam) {
				RenderText(TextShader, "CAMARA LIBRE ",
					SCREEN_WIDTH - 200.0f,         // Coordenada X (ancho de la pantalla menos 200 píxeles)
					SCREEN_HEIGHT - 30.0f,         // Coordenada Y (altura menos 30 píxeles)
					0.35f,                         // Escala del texto
					glm::vec3(0.7f, 0.7f, 0.11f)); // Color del texto
			}

			// Si la cámara está en modo estático, renderiza el texto "CAMARA ESTATICA" en la esquina superior derecha
			if (onFreeCam) {
				RenderText(TextShader, "CAMARA ESTATICA ",
					SCREEN_WIDTH - 200.0f,         // Coordenada X
					SCREEN_HEIGHT - 60.0f,         // Coordenada Y (altura menos 60 píxeles para que no se superponga)
					0.35f,                         // Escala del texto
					glm::vec3(0.7f, 0.7f, 0.11f)); // Color del texto
			}
			// Fin del bloque de renderizado
			break;
		}
		if (PlanetVista > 0)
			RenderText(TextShader, "CÁMARA PLANETARIA ", SCREEN_WIDTH - 200.0f, SCREEN_HEIGHT - 30.0f, 0.35f, glm::vec3(0.7f, 0.7f, 0.11f));
		/* SEGUIMIENTO DEL PLANETA + MOSTRAR INFORMACIÓN DEL PLANETA */

		// -------------------------------------------------------------------------------
		glfwSwapBuffers(window);
		glfwPollEvents();
	}

	glDeleteVertexArrays(1, &VAO_t);
	glDeleteBuffers(1, &VBO_t);
	glfwTerminate();
	return 0;
}

// Función que procesa la entrada del teclado para controlar la cámara y el comportamiento del sistema
void processInput(GLFWwindow* window)
{
	// Si la tecla ESCAPE es presionada, cierra la ventana
	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
		glfwSetWindowShouldClose(window, true);

}

void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
	glViewport(0, 0, width, height);
}

// Función para cargar una textura cúbica (cubemap) a partir de una lista de rutas de imágenes
unsigned int loadCubemap(std::vector<std::string> faces)
{
	// Declara una variable para almacenar el ID de la textura
	unsigned int textureID;

	// Genera una nueva textura y asigna el ID generado a textureID
	glGenTextures(1, &textureID);

	// Asocia la textura actual al objetivo de textura cúbica
	glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);

	// Variables para almacenar las dimensiones y canales de las imágenes
	int width, height, nrChannels;

	// Recorre las caras del cubemap, que son las imágenes en las rutas proporcionadas
	for (unsigned int i = 0; i < faces.size(); i++)
	{
		// Carga la imagen de la ruta indicada por faces[i]
		unsigned char* data = stbi_load(faces[i].c_str(), &width, &height, &nrChannels, 0);

		// Si la imagen se cargó correctamente
		if (data)
		{
			// Carga la imagen como una cara del cubemap (una cara por cada valor de i)
			glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,
				0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);

			// Libera la memoria de la imagen después de cargarla
			stbi_image_free(data);
		}
		else
		{
			// Si la imagen no se pudo cargar, muestra un mensaje de error
			std::cout << "La textura del cubemap no se pudo cargar en la ruta especificada: " << faces[i] << std::endl;
			// Asegúrate de liberar la memoria de los datos aunque la carga haya fallado
			stbi_image_free(data);
		}
	}

	// Configura los parámetros de filtrado y envolvimiento para la textura cúbica
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);  // Filtrado de minificación
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);  // Filtrado de magnificación
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);  // Envolvimiento en el eje S
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);  // Envolvimiento en el eje T
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);  // Envolvimiento en el eje R

	// Devuelve el ID de la textura cúbica cargada
	return textureID;
}

unsigned int loadTexture(char const* path)
{
	unsigned int textureID;
	glGenTextures(1, &textureID);

	int width, height, nrComponents;
	unsigned char* data = stbi_load(path, &width, &height, &nrComponents, 0);
	if (data)
	{
		GLenum format;
		if (nrComponents == 1)
			format = GL_RED;
		else if (nrComponents == 3)
			format = GL_RGB;
		else if (nrComponents == 4)
			format = GL_RGBA;

		glBindTexture(GL_TEXTURE_2D, textureID);
		glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);
		glGenerateMipmap(GL_TEXTURE_2D);

		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

		stbi_image_free(data);
	}
	else
	{
		std::cout << "La textura no se ha podido cargar en la ruta: " << path << std::endl;
		stbi_image_free(data);
	}

	return textureID;
}
void RenderText(Shader& s, std::string text, GLfloat x, GLfloat y, GLfloat scale, glm::vec3 color)
{
	// Activar el estado de renderizado correspondiente	
	s.Use();
	glUniform3f(glGetUniformLocation(s.ID, "textColor"), color.x, color.y, color.z);
	glActiveTexture(GL_TEXTURE0);
	glBindVertexArray(textVAO);

	// Iterar a través de todos los caracteres
	std::string::const_iterator c;
	for (c = text.begin(); c != text.end(); c++)
	{
		Character ch = Characters[*c];

		GLfloat xpos = x + ch.Bearing.x * scale;
		GLfloat ypos = y - (ch.Size.y - ch.Bearing.y) * scale;

		GLfloat w = ch.Size.x * scale;
		GLfloat h = ch.Size.y * scale;
		// Actualizar el VBO para cada carácter
		GLfloat vertices[6][4] = {
			{ xpos,     ypos + h,   0.0, 0.0 },
			{ xpos,     ypos,       0.0, 1.0 },
			{ xpos + w, ypos,       1.0, 1.0 },

			{ xpos,     ypos + h,   0.0, 0.0 },
			{ xpos + w, ypos,       1.0, 1.0 },
			{ xpos + w, ypos + h,   1.0, 0.0 }
		};
		// Renderizar la textura del glifo sobre el cuadrilátero
		glBindTexture(GL_TEXTURE_2D, ch.TextureID);
		// Actualizar el contenido de la memoria del VBO
		glBindBuffer(GL_ARRAY_BUFFER, textVBO);
		glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices);
		glBindBuffer(GL_ARRAY_BUFFER, 0);
		// Renderizar el cuadrilátero
		glDrawArrays(GL_TRIANGLES, 0, 6);
		// Ahora avanzar el cursor para el siguiente glifo (notar que advance es el número de 1/64 píxeles)
		x += (ch.Advance >> 6) * scale; // Desplazar 6 bits para obtener el valor en píxeles (2^6 = 64)
	}
	glBindVertexArray(0);
	glBindTexture(GL_TEXTURE_2D, 0);
}

// Método para mostrar información del planeta en pantalla
void ShowInfo(Shader& s) // Recibe un shader como referencia para renderizar el texto
{
	// Renderiza el nombre del planeta en la parte superior izquierda
	RenderText(s,
		"Planeta: " + Info.Name,       // Texto que incluye "Planet: " concatenado con el nombre del planeta
		25.0f,                        // Posición X, 25 píxeles desde el borde izquierdo
		SCREEN_HEIGHT - 30.0f,        // Posición Y, altura total de la pantalla menos 30 píxeles
		0.35f,                        // Escala del texto, determina su tamaño
		glm::vec3(0.7f, 0.7f, 0.11f));// Color del texto en formato RGB (un amarillo claro)

}
